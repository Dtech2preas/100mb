<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>DTech AI Assistant</title>
<link rel="manifest" href="manifest.json">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0f172a">
<link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">

<!-- KaTeX (Math) -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

<!-- Highlight.js (Code) -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<!-- PDF.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
    // Set worker source for PDF.js
    window.pdfjsLib = window['pdfjs-dist/build/pdf'];
    if (window.pdfjsLib) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }
</script>

<style>
  :root { 
      --primary: #10b981; /* Emerald Green */
      --bg: #0f172a; /* Slate 900 */
      --surface: rgba(30, 41, 59, 0.7); /* Slate 800 + Opacity */
      --text: #f1f5f9; 
      --msg-user: #10b981; 
      --msg-ai: #1e293b; 
      --glass: blur(12px) saturate(180%);
  }
  
  body { 
      font-family: 'Inter', sans-serif; 
      background: radial-gradient(circle at top, #1e293b, #0f172a);
      color: var(--text); 
      margin: 0; 
      display: flex; 
      flex-direction: column; 
      height: 100vh; height: 100dvh; 
      overflow: hidden; 
  }

  header { 
      background-color: var(--surface); 
      backdrop-filter: var(--glass);
      -webkit-backdrop-filter: var(--glass);
      padding: 15px 20px; 
      border-bottom: 1px solid rgba(255,255,255,0.05); 
      flex-shrink: 0; 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      z-index: 10;
  }
  
  h1 { margin: 0; font-size: 1.1rem; color: var(--primary); font-weight: 600; letter-spacing: -0.5px; }
  
  .icon-btn { 
      background: none; border: none; color: #94a3b8; 
      cursor: pointer; padding: 8px; border-radius: 12px; 
      display: flex; align-items: center; justify-content: center; 
      transition: all 0.2s;
  }
  .icon-btn:hover { color: white; background-color: rgba(255,255,255,0.1); }
  
  /* Menu */
  #menu-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); backdrop-filter: blur(5px); z-index: 2000; display: none; justify-content: center; align-items: center; }
  #menu-box { 
      background: #1e293b; 
      width: 85%; max-width: 350px; 
      padding: 25px; 
      border-radius: 20px; 
      border: 1px solid rgba(255,255,255,0.1); 
      box-shadow: 0 20px 50px rgba(0,0,0,0.5);
      animation: scaleIn 0.2s ease-out;
  }
  @keyframes scaleIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }

  .menu-item { margin-bottom: 20px; }
  .menu-item label { display: block; margin-bottom: 8px; color: #94a3b8; font-size: 0.85rem; font-weight: 500; }
  select { width: 100%; background: #0f172a; color: white; padding: 12px; border-radius: 10px; border: 1px solid #334155; outline: none; font-family: inherit; }
  
  #chat-container { flex: 1; overflow-y: auto; padding: 20px 15px; display: flex; flex-direction: column; gap: 15px; scroll-behavior: smooth; }
  
  .message { 
      max-width: 88%; padding: 14px 18px; 
      border-radius: 20px; line-height: 1.6; 
      word-wrap: break-word; font-size: 0.95rem; 
      position: relative; 
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      animation: slideUp 0.3s ease-out forwards;
  }
  @keyframes slideUp { from { transform: translateY(10px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

  .user { align-self: flex-end; background: linear-gradient(135deg, #10b981, #059669); color: white; border-bottom-right-radius: 4px; }
  .ai { align-self: flex-start; background-color: var(--msg-ai); border: 1px solid rgba(255,255,255,0.05); color: var(--text); border-bottom-left-radius: 4px; }
  
  /* Markdown Styles */
  .ai strong { color: #81c784; font-weight: 700; }
  .ai em { font-style: italic; color: #a5d6a7; }
  .ai ul, .ai ol { margin: 8px 0; padding-left: 20px; }
  .ai li { margin-bottom: 4px; }
  
  /* Code Blocks */
  .ai pre { background: #282c34; padding: 0; border-radius: 8px; overflow: hidden; margin: 8px 0; border: 1px solid #333; position: relative; }
  .ai pre code { font-family: monospace; display: block; padding: 12px; overflow-x: auto; padding-top: 35px; /* Space for copy button */ }
  .ai code { font-family: monospace; background: rgba(255,255,255,0.1); padding: 2px 4px; border-radius: 4px; font-size: 0.9em; }
  .ai pre code.hljs { background: #282c34; color: #abb2bf; }
  
  .copy-btn { position: absolute; top: 5px; right: 5px; background: rgba(255,255,255,0.1); color: #aaa; border: none; padding: 4px 8px; border-radius: 4px; font-size: 0.75rem; cursor: pointer; display: flex; align-items: center; gap: 4px; }
  .copy-btn:hover { background: rgba(255,255,255,0.2); color: white; }
  
  /* Math Overrides */
  .katex { font-size: 1.1em; color: #e0e0e0; }
  .katex-display { margin: 1em 0; overflow-x: auto; overflow-y: hidden; }
  
  .tts-btn { position: absolute; bottom: -22px; left: 10px; font-size: 18px; color: #666; cursor: pointer; opacity: 0.7; transition: opacity 0.2s; padding: 2px; }
  .tts-btn:active { color: var(--primary); opacity: 1; }

  /* Suggestion Chips */
  #chips { display: flex; gap: 8px; padding: 10px 15px; overflow-x: auto; scrollbar-width: none; -ms-overflow-style: none; white-space: nowrap; flex-shrink: 0; }
  #chips::-webkit-scrollbar { display: none; }
  .chip { 
      background: rgba(30, 41, 59, 0.6); 
      border: 1px solid rgba(255,255,255,0.1); 
      color: #94a3b8; 
      padding: 8px 16px; 
      border-radius: 20px; 
      font-size: 0.8rem; font-weight: 500;
      cursor: pointer; transition: all 0.2s; 
  }
  .chip:hover { background: rgba(16, 185, 129, 0.1); border-color: var(--primary); color: var(--primary); }

  /* Doc Indicator */
  #doc-indicator { font-size: 0.8rem; color: #10b981; margin-left: 10px; display: none; align-items: center; gap: 5px; }

  /* Search Toggle */
  #search-toggle { margin-right: 8px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: #64748b; transition: all 0.2s; padding: 8px; border-radius: 50%; }
  #search-toggle:hover { background: rgba(255,255,255,0.05); }
  #search-toggle.active { color: #3b82f6; background: rgba(59, 130, 246, 0.1); }

  #input-area { 
      background: transparent; 
      padding: 15px; 
      padding-bottom: max(15px, env(safe-area-inset-bottom)); 
      display: flex; gap: 10px; 
      flex-shrink: 0; align-items: flex-end; 
  }
  
  #input-wrapper { 
      flex: 1; position: relative; display: flex; align-items: center; 
      background: var(--surface);
      backdrop-filter: var(--glass);
      -webkit-backdrop-filter: var(--glass);
      border-radius: 28px;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
  }
  
  input { 
      width: 100%; padding: 14px 45px 14px 18px; 
      border-radius: 28px; border: none; 
      background: transparent; 
      color: white; outline: none; font-size: 1rem; font-family: inherit;
      box-sizing: border-box; 
  }
  
  #mic-btn { position: absolute; right: 8px; color: #94a3b8; background: none; border: none; cursor: pointer; padding: 8px; border-radius: 50%; transition: color 0.2s; }
  #mic-btn:hover { color: white; }
  #mic-btn.listening { color: #f43f5e; animation: pulse 1.5s infinite; }
  
  #stop-speak-btn { color: #f43f5e; display: none; background: none; border: none; cursor: pointer; position: absolute; right: 45px; padding: 8px; }
  
  #send-btn { 
      background: linear-gradient(135deg, #10b981, #059669); 
      color: white; border: none; 
      width: 50px; height: 50px; 
      border-radius: 50%; 
      display: flex; align-items: center; justify-content: center; 
      cursor: pointer; 
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
      flex-shrink: 0;
  }
  #send-btn:hover { transform: scale(1.05); }
  #send-btn:active { transform: scale(0.95); }
  #send-btn:disabled { background: #334155; opacity: 0.7; cursor: not-allowed; box-shadow: none; }
  
  @keyframes pulse { 0% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(1.1); } 100% { opacity: 1; transform: scale(1); } }
  
  /* Call Overlay */
  #call-overlay { 
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
      background: rgba(15, 23, 42, 0.95); backdrop-filter: blur(20px);
      z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center; 
      opacity: 0; pointer-events: none; transition: opacity 0.4s ease; 
  }
  #call-overlay.active { opacity: 1; pointer-events: all; }
  
  .visualizer-container { position: relative; width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; }
  .visualizer { 
      width: 120px; height: 120px; border-radius: 50%; 
      background: linear-gradient(135deg, #10b981, #059669); 
      box-shadow: 0 0 50px rgba(16, 185, 129, 0.5); 
      animation: breathe 3s infinite ease-in-out; 
      display: flex; align-items: center; justify-content: center; z-index: 2;
  }
  .pulse-ring {
      position: absolute; width: 100%; height: 100%; border-radius: 50%; border: 2px solid rgba(16, 185, 129, 0.3);
      animation: ripple 2s infinite linear; opacity: 0;
  }
  .pulse-ring:nth-child(2) { animation-delay: 1s; }
  
  @keyframes breathe { 0% { transform: scale(0.95); opacity: 0.9; box-shadow: 0 0 30px rgba(16, 185, 129, 0.4); } 50% { transform: scale(1.05); opacity: 1; box-shadow: 0 0 60px rgba(16, 185, 129, 0.7); } 100% { transform: scale(0.95); opacity: 0.9; box-shadow: 0 0 30px rgba(16, 185, 129, 0.4); } }
  @keyframes ripple { 0% { transform: scale(0.6); opacity: 1; } 100% { transform: scale(1.5); opacity: 0; } }

  .status-text { margin-top: 40px; font-size: 1.4rem; color: #e2e8f0; font-weight: 300; letter-spacing: 1px; }
  
  .call-controls { display: flex; gap: 30px; margin-top: 80px; }
  
  #hangup-btn { 
      background: #f43f5e; width: 70px; height: 70px; 
      border-radius: 50%; border: none; color: white; font-size: 32px; 
      display: flex; align-items: center; justify-content: center; 
      cursor: pointer; box-shadow: 0 10px 25px rgba(244, 63, 94, 0.4); 
      transition: transform 0.2s;
  }
  #hangup-btn:active { transform: scale(0.9); }
  
  #stop-talk-call-btn { 
      background: #334155; width: 70px; height: 70px; 
      border-radius: 50%; border: none; color: #cbd5e1; font-size: 32px; 
      display: flex; align-items: center; justify-content: center; 
      cursor: pointer; box-shadow: 0 10px 25px rgba(0,0,0,0.3); display: none; 
      transition: all 0.2s;
  }
  #stop-talk-call-btn:hover { background: #475569; color: white; }

</style>
</head>
<body>
<div id="call-overlay">
  <div class="visualizer-container">
      <div class="pulse-ring"></div>
      <div class="pulse-ring"></div>
      <div class="visualizer"><span class="material-icons-round" style="font-size: 56px; color: white;">graphic_eq</span></div>
  </div>
  <div class="status-text" id="call-status">Listening...</div>
  <div class="call-controls">
      <button id="stop-talk-call-btn" title="Stop Speaking"><span class="material-icons-round">volume_off</span></button>
      <button id="hangup-btn" title="End Call"><span class="material-icons-round">call_end</span></button>
  </div>
</div>

<header>
  <h1>ðŸ‡¿ðŸ‡¦ DTech AI Assistant</h1>
  <div style="display:flex; gap:10px;">
    <button class="icon-btn" id="settings-btn" title="Settings"><span class="material-icons-round">settings</span></button>
    <button class="icon-btn" id="call-btn" title="Start Live Call"><span class="material-icons-round">headset_mic</span></button>
    <button class="icon-btn" id="clear-btn" title="Clear Chat"><span class="material-icons-round">delete_outline</span></button>
  </div>
</header>

<div id="menu-overlay">
  <div id="menu-box">
     <h2 style="margin-top:0; color:var(--primary);">Settings</h2>
     
     <div class="menu-item">
        <label>Persona (Personality)</label>
        <select id="persona-select">
            <option value="default">Default (Helpful AI)</option>
            <option value="tutor">Strict Tutor (School Syllabus)</option>
            <option value="coder">Senior Developer (Code Only)</option>
            <option value="creative">Creative Writer</option>
            <option value="pirate">Pirate (Just for fun)</option>
        </select>
     </div>
     
     <button id="close-menu" style="width:100%; padding:10px; background:var(--primary); color:white; border:none; border-radius:8px; cursor:pointer;">Save & Close</button>
  </div>
</div>

<div id="chat-container"></div>

<div id="chips">
  <div class="chip">Explain simpler</div>
  <div class="chip">Give an example</div>
  <div class="chip">Quiz me</div>
  <div class="chip">Summarize</div>
</div>

<div id="image-preview" style="display:none; padding: 0 15px; margin-bottom: 5px;">
  <div style="position:relative; display:inline-block;">
    <img id="preview-img" style="height: 60px; border-radius: 8px; border: 1px solid #333;">
    <button id="remove-img" style="position:absolute; top:-5px; right:-5px; background:red; color:white; border-radius:50%; width:18px; height:18px; border:none; font-size:12px; cursor:pointer;">&times;</button>
  </div>
</div>

<div id="doc-preview" style="display:none; padding: 0 15px; margin-bottom: 5px;">
   <span style="background: rgba(255,255,255,0.1); padding: 5px 10px; border-radius: 12px; font-size: 0.85rem; display: inline-flex; align-items: center; gap: 5px;">
      <span class="material-icons-round" style="font-size: 16px;">description</span>
      <span id="doc-name">Document.pdf</span>
      <button id="remove-doc" style="background:none; border:none; color:#aaa; cursor:pointer; font-size:16px; padding:0; margin-left:5px;">&times;</button>
   </span>
</div>

<form id="input-area">
  <div id="input-wrapper">
    <input type="file" id="file-input" accept="image/*" style="display:none">
    <input type="file" id="doc-input" accept="application/pdf" style="display:none">
    
    <button type="button" id="search-toggle" title="Web Search"><span class="material-icons-round">public</span></button>

    <button type="button" id="cam-btn" title="Add Image" style="color:#888; background:none; border:none; cursor:pointer; padding-left:5px;"><span class="material-icons-round">add_a_photo</span></button>
    <button type="button" id="doc-btn" title="Add PDF" style="color:#888; background:none; border:none; cursor:pointer;"><span class="material-icons-round">attach_file</span></button>
    
    <input type="text" id="user-input" placeholder="Ask anything..." autocomplete="off" required>
    
    <button type="button" id="stop-speak-btn" title="Stop Speaking"><span class="material-icons-round">volume_off</span></button>
    <button type="button" id="mic-btn"><span class="material-icons-round">mic</span></button>
  </div>
  <button type="submit" id="send-btn"><span class="material-icons-round">send</span></button>
</form>

<script>
  // CONFIGURATION
  const WORKER_URL = "https://super-surf-282e.jonasmochebane.workers.dev/";

  const form = document.getElementById('input-area');
  const input = document.getElementById('user-input');
  const chat = document.getElementById('chat-container');
  const sendBtn = document.getElementById('send-btn');
  const micBtn = document.getElementById('mic-btn');
  const stopSpeakBtn = document.getElementById('stop-speak-btn');
  const clearBtn = document.getElementById('clear-btn');
  const settingsBtn = document.getElementById('settings-btn');
  const menuOverlay = document.getElementById('menu-overlay');
  const closeMenuBtn = document.getElementById('close-menu');
  const personaSelect = document.getElementById('persona-select');

  const camBtn = document.getElementById('cam-btn');
  const fileInput = document.getElementById('file-input');
  const previewContainer = document.getElementById('image-preview');
  const previewImg = document.getElementById('preview-img');
  const removeImgBtn = document.getElementById('remove-img');

  // PDF UI
  const docBtn = document.getElementById('doc-btn');
  const docInput = document.getElementById('doc-input');
  const docPreview = document.getElementById('doc-preview');
  const docName = document.getElementById('doc-name');
  const removeDocBtn = document.getElementById('remove-doc');
  const searchToggle = document.getElementById('search-toggle');

  // Call UI
  const callBtn = document.getElementById('call-btn');
  const callOverlay = document.getElementById('call-overlay');
  const hangupBtn = document.getElementById('hangup-btn');
  const stopTalkCallBtn = document.getElementById('stop-talk-call-btn');
  const callStatus = document.getElementById('call-status');

  // State
  let history = JSON.parse(localStorage.getItem('dtech_history')) || [];
  let persona = localStorage.getItem('dtech_persona') || 'default';
  personaSelect.value = persona;
  
  let currentImageArray = null;
  let currentDocText = null;
  let isCallActive = false;
  let isAIProcessing = false;
  let isWebSearch = false;
  let ttsBuffer = "";
  let shouldSpeakLive = false;
  let sseBuffer = ""; // Buffer for partial SSE lines
  
  // Init
  window.addEventListener('DOMContentLoaded', () => {
    if (history.length === 0) {
      addMessage("Hello! I'm your DTech AI assistant. How can I help you today?", 'ai', false);
    } else {
      history.forEach(msg => renderMessage(msg.content, msg.role));
      setTimeout(scrollToBottom, 100);
    }
  });

  // --- Core Logic ---

  function saveHistory() {
    localStorage.setItem('dtech_history', JSON.stringify(history));
  }

  function scrollToBottom() {
    chat.scrollTop = chat.scrollHeight;
  }

  // Markdown Parser
  function parseMarkdown(text) {
    let html = text
      .replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") // Escape
      .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>') // Code blocks
      .replace(/`([^`]+)`/g, '<code>$1</code>') // Inline code
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
      .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic
      .replace(/(?:^|\n)- (.*)/g, '<li>$1</li>') // List items
      .replace(/(<li>[\s\S]*?<\/li>)/g, '<ul>$1</ul>') // Wrap lists
      .replace(/\n/g, '<br>'); // Newlines
    
    // Fix lists (crude but effective for simple chats)
    html = html.replace(/<br><li>/g, '<li>');
    return html;
  }

  function renderMessage(text, role, isStreaming = false) {
    let div = document.getElementById(`msg-${history.length}`);
    
    // If it's a new message (not updating a stream)
    if (!div || !isStreaming) {
       div = document.createElement('div');
       div.classList.add('message', role);
       if (role === 'ai') {
           // Add TTS button
           const tts = document.createElement('span');
           tts.className = 'material-icons-round tts-btn';
           tts.innerText = 'volume_up';
           tts.onclick = () => speak(text);
           div.appendChild(tts);
       }
       chat.appendChild(div);
    }
    
    // Update content
    const contentHtml = parseMarkdown(text);
    // Use a content wrapper to preserve the TTS button
    const contentSpan = div.querySelector('.content') || document.createElement('div');
    contentSpan.className = 'content';
    contentSpan.innerHTML = contentHtml;
    if (!div.querySelector('.content')) div.prepend(contentSpan);

    // Apply Math (KaTeX)
    if (window.renderMathInElement) {
        try {
            renderMathInElement(contentSpan, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                throwOnError: false
            });
        } catch(e) {}
    }

    // Apply Code Highlighting (Highlight.js) & Copy Button
    if (window.hljs) {
        contentSpan.querySelectorAll('pre').forEach((pre) => {
             // Avoid double-adding if re-rendering (though we create new elements usually)
             if (pre.querySelector('.copy-btn')) return;

             const code = pre.querySelector('code');
             if(code) {
                 hljs.highlightElement(code);
                 
                 // Create Copy Button
                 const btn = document.createElement('button');
                 btn.className = 'copy-btn';
                 btn.innerHTML = '<span class="material-icons-round" style="font-size:14px;">content_copy</span> Copy';
                 btn.onclick = () => {
                     navigator.clipboard.writeText(code.innerText);
                     btn.innerHTML = '<span class="material-icons-round" style="font-size:14px;">check</span> Copied';
                     setTimeout(() => btn.innerHTML = '<span class="material-icons-round" style="font-size:14px;">content_copy</span> Copy', 2000);
                 };
                 pre.appendChild(btn);
             }
        });
    }
    
    scrollToBottom();
    return div;
  }

  function addMessage(text, role, save = true) {
    if (save) {
        history.push({ role, content: text });
        saveHistory();
    }
    renderMessage(text, role);
  }

  // --- Voice & Call Logic ---
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  let recognition;
  
  function speak(text, onEndCallback) {
    // If not appending to a queue (like manual click), clear everything
    if (!onEndCallback && !shouldSpeakLive) {
        window.speechSynthesis.cancel();
    }
    
    // Show Stop Button
    stopSpeakBtn.style.display = 'block';
    if(isCallActive) stopTalkCallBtn.style.display = 'block';

    // Strip markdown chars for smoother reading
    let cleanText = text.replace(/[*_#`]/g, '');
    const utterance = new SpeechSynthesisUtterance(cleanText);
    utterance.lang = 'en-ZA'; 
    utterance.rate = 1.1; 
    
    utterance.onend = () => {
        if (onEndCallback) onEndCallback();
        // Hide stop button if queue is empty
        if (!window.speechSynthesis.speaking) {
            stopSpeakBtn.style.display = 'none';
            stopTalkCallBtn.style.display = 'none';
        }
    };
    
    utterance.onerror = () => {
        stopSpeakBtn.style.display = 'none';
        stopTalkCallBtn.style.display = 'none';
    };

    window.speechSynthesis.speak(utterance);
  }

  function stopSpeaking() {
      window.speechSynthesis.cancel();
      stopSpeakBtn.style.display = 'none';
      stopTalkCallBtn.style.display = 'none';
      shouldSpeakLive = false; // Stop auto-reading for this stream
      ttsBuffer = "";
      
      // If in Call Mode, stopping speech should resume listening
      if (isCallActive) {
          isAIProcessing = false;
          callStatus.innerText = "Listening...";
          try { recognition.start(); } catch(e){}
      }
  }
  
  stopSpeakBtn.onclick = stopSpeaking;
  stopTalkCallBtn.onclick = stopSpeaking;

  // TTS Buffer Logic for Low Latency
  function processTTSBuffer(isFinal = false) {
      if (!shouldSpeakLive) return;

      // Split by sentence terminators
      // Match sentence endings followed by space or end of string
      const sentenceRegex = /([.?!]+[\s\n]+)/; 
      
      let parts = ttsBuffer.split(sentenceRegex);
      
      // If we have at least one complete sentence (part + delimiter + remainder)
      // split returns [text, delimiter, text, delimiter, remainder]
      
      while (parts.length > 2) {
          const sentence = parts.shift();
          const delimiter = parts.shift();
          const textToSpeak = sentence + delimiter;
          
          speak(textToSpeak, null); // Queue it up
      }
      
      // Reconstruct buffer with remainder
      ttsBuffer = parts.join('');
      
      // If final, speak the rest
      if (isFinal && ttsBuffer.trim()) {
          speak(ttsBuffer, () => {
              if (isCallActive) {
                  isAIProcessing = false;
                  callStatus.innerText = "Listening...";
                  try { recognition.start(); } catch(e){}
              }
          });
          ttsBuffer = "";
      }
  }


  if (SpeechRecognition) {
    recognition = new SpeechRecognition();
    recognition.continuous = false;
    recognition.interimResults = false;
    recognition.lang = 'en-ZA';

    // Standard Mic Button
    micBtn.onclick = () => {
        if (micBtn.classList.contains('listening')) recognition.stop();
        else recognition.start();
    };
    
    recognition.onstart = () => {
        micBtn.classList.add('listening');
        if (isCallActive) callStatus.innerText = "Listening...";
    };
    
    recognition.onend = () => {
        micBtn.classList.remove('listening');
        // Loop for Call Mode
        if (isCallActive && !isAIProcessing) {
             try { recognition.start(); } catch(e){}
        }
    };

    recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        
        if (isCallActive) {
            // Live Call Flow
            input.value = transcript; 
            isAIProcessing = true; 
            recognition.stop(); 
            callStatus.innerText = "Thinking...";
            form.requestSubmit(); 
        } else {
            // Standard Mic
            input.value = transcript;
            input.focus();
        }
    };
  } else {
    micBtn.style.display = 'none';
    callBtn.style.display = 'none';
  }

  // Call Mode Controls
  callBtn.onclick = () => {
    isCallActive = true;
    callOverlay.classList.add('active');
    try { recognition.start(); } catch(e){}
  };

  hangupBtn.onclick = () => {
    isCallActive = false;
    isAIProcessing = false;
    shouldSpeakLive = false;
    callOverlay.classList.remove('active');
    recognition.stop();
    window.speechSynthesis.cancel();
  };

  // --- Images ---

  camBtn.onclick = () => fileInput.click();
  
  fileInput.onchange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    // Show Preview
    const reader = new FileReader();
    reader.onload = (e) => {
        previewImg.src = e.target.result;
        previewContainer.style.display = 'block';
    };
    reader.readAsDataURL(file);

    // Process for Backend (Resize & Convert to Array)
    const img = new Image();
    img.src = URL.createObjectURL(file);
    await new Promise(r => img.onload = r);

    const canvas = document.createElement('canvas');
    const MAX_WIDTH = 800;
    const scaleSize = MAX_WIDTH / img.width;
    canvas.width = MAX_WIDTH;
    canvas.height = img.height * scaleSize;

    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    canvas.toBlob(async (blob) => {
        const buf = await blob.arrayBuffer();
        currentImageArray = Array.from(new Uint8Array(buf));
    }, 'image/jpeg', 0.7);
  };

  removeImgBtn.onclick = () => {
    fileInput.value = '';
    currentImageArray = null;
    previewContainer.style.display = 'none';
  };

  // --- PDF Logic ---
  docBtn.onclick = () => docInput.click();

  docInput.onchange = async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      if (file.type !== 'application/pdf') {
          alert('Please upload a PDF file.');
          return;
      }

      // Show Loading State
      docName.innerText = "Reading PDF...";
      docPreview.style.display = 'block';
      input.disabled = true;

      try {
          const arrayBuffer = await file.arrayBuffer();
          const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
          let fullText = "";

          // Extract text from first 5 pages (to prevent overload)
          const maxPages = Math.min(pdf.numPages, 5);
          for (let i = 1; i <= maxPages; i++) {
              const page = await pdf.getPage(i);
              const textContent = await page.getTextContent();
              const pageText = textContent.items.map(item => item.str).join(' ');
              fullText += `[Page ${i}]\n${pageText}\n\n`;
          }

          if (pdf.numPages > 5) fullText += "\n[...Document Truncated...]";

          currentDocText = fullText;
          docName.innerText = file.name;
          input.disabled = false;
          input.placeholder = "Ask about the document...";
          input.focus();

      } catch (err) {
          console.error(err);
          alert("Could not read PDF. Please try a simpler file.");
          docPreview.style.display = 'none';
          input.disabled = false;
          docInput.value = '';
      }
  };

  removeDocBtn.onclick = () => {
      docInput.value = '';
      currentDocText = null;
      docPreview.style.display = 'none';
      input.placeholder = "Ask anything...";
  };

  // --- Search Logic ---
  searchToggle.onclick = () => {
      isWebSearch = !isWebSearch;
      searchToggle.classList.toggle('active', isWebSearch);
  };

  // --- Menu ---
  settingsBtn.onclick = () => menuOverlay.style.display = 'flex';
  closeMenuBtn.onclick = () => {
      persona = personaSelect.value;
      localStorage.setItem('dtech_persona', persona);
      menuOverlay.style.display = 'none';
  };
  menuOverlay.onclick = (e) => {
      if(e.target === menuOverlay) menuOverlay.style.display = 'none';
  };

  // --- Interaction ---
  
  clearBtn.onclick = () => {
    if(confirm('Clear conversation history?')) {
        history = [];
        saveHistory();
        chat.innerHTML = '';
        addMessage("Chat cleared. How can I help?", 'ai');
    }
  };

  document.querySelectorAll('.chip').forEach(chip => {
    chip.onclick = () => {
        input.value = chip.innerText;
        form.requestSubmit();
    };
  });

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const text = input.value.trim();
    if (!text && !currentImageArray && !currentDocText) return;

    input.value = '';
    
    // Display user message (without the huge PDF text)
    addMessage(text || (currentImageArray ? "Analyze this image" : "Analyze this document"), 'user');
    
    // Create placeholder for AI
    const aiMsgIndex = history.length; 
    // Temp entry for streaming
    history.push({ role: 'ai', content: '' }); 
    const aiDiv = document.createElement('div');
    aiDiv.classList.add('message', 'ai');
    aiDiv.id = `msg-${aiMsgIndex}`;
    aiDiv.innerHTML = '<div class="content"><div class="loader" style="width:10px;height:10px;border-width:2px;animation:spin 1s linear infinite;"></div></div>';
    chat.appendChild(aiDiv);
    scrollToBottom();

    // Prepare Payload (Increased Context)
    const context = history.slice(0, -1).slice(-20); // Last 20 messages
    let payload = { messages: context, web_search: isWebSearch };

    // Inject Persona System Message (Override default)
    const personas = {
        'default': 'You are a helpful and friendly AI assistant.',
        'tutor': 'You are a strict South African school tutor. Keep answers relevant to the syllabus.',
        'coder': 'You are a Senior Software Engineer. Provide efficient, commented code. Minimize explanation.',
        'creative': 'You are a creative writer. Use evocative language and vivid imagery.',
        'pirate': 'You are a pirate captain. Speak in nautical slang and be adventurous!'
    };
    
    // We prepend this as a system message to the context being sent
    // Note: The worker also checks for system messages, so we make sure this is the first one
    const systemPrompt = personas[persona] || personas['default'];
    payload.messages = [{role: 'system', content: systemPrompt}, ...payload.messages];
    
    // Inject PDF Text if present
    if (currentDocText) {
        // We append the PDF text to the user's prompt invisibly to the UI history, 
        // but visible to the AI. 
        // Logic: Modify the last message in 'context' OR add a temporary system message.
        // Better: Construct the prompt sent to AI to include it.
        
        const combinedPrompt = `${text}\n\n--- Attached Document ---\n${currentDocText}`;
        // Replace the last user message content in the payload
        payload.messages[payload.messages.length - 1].content = combinedPrompt;
        
        // Reset UI
        currentDocText = null;
        docInput.value = '';
        docPreview.style.display = 'none';
        input.placeholder = "Ask anything...";
    }

    if (currentImageArray) {
        payload.image = currentImageArray;
        currentImageArray = null;
        fileInput.value = '';
        previewContainer.style.display = 'none';
    }

    // Init TTS Buffer if call or if user wants auto-speak (currently only call)
    ttsBuffer = "";
    shouldSpeakLive = isCallActive;
    if (shouldSpeakLive) {
        window.speechSynthesis.cancel();
        callStatus.innerText = "Speaking...";
    }

    try {
      const response = await fetch(WORKER_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) throw new Error(await response.text());

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let fullResponse = "";
      sseBuffer = "";

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        const chunk = decoder.decode(value, { stream: true });
        
        sseBuffer += chunk;
        const lines = sseBuffer.split('\n');
        // Keep the last partial line in the buffer
        sseBuffer = lines.pop(); 
        
        for (const line of lines) {
            if (line.startsWith('data: ')) {
                try {
                    const data = JSON.parse(line.slice(6));
                    if (data.response) {
                        fullResponse += data.response;
                        // Add to TTS buffer
                        ttsBuffer += data.response;
                        processTTSBuffer(false);
                        
                        // Update UI live
                        const contentDiv = aiDiv.querySelector('.content');
                        contentDiv.innerHTML = parseMarkdown(fullResponse);
                        scrollToBottom();
                    }
                } catch (e) { }
            }
        }
      }
      
      // Final Processing
      processTTSBuffer(true);

      // Final Save
      history[aiMsgIndex].content = fullResponse;
      saveHistory();
      
      // Add TTS button finally
      const tts = document.createElement('span');
      tts.className = 'material-icons-round tts-btn';
      tts.innerText = 'volume_up';
      tts.onclick = () => speak(fullResponse);
      aiDiv.appendChild(tts);

    } catch (err) {
      if (isCallActive) {
          speak("Sorry, I had a connection error.");
          isAIProcessing = false;
      }
      history.pop(); 
      
      let errorMsg = err.message;
      try {
          const jsonErr = JSON.parse(errorMsg);
          if (jsonErr.error) errorMsg = jsonErr.error;
      } catch (e) {}

      aiDiv.innerHTML = '<div class="content" style="color:#ff6b6b; border: 1px solid #ff6b6b; padding: 10px; border-radius: 8px; background: rgba(255, 107, 107, 0.1);"><strong>Error:</strong> ' + errorMsg + '</div>';
    }
  });
</script>
</body>
</html>
