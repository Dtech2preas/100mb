<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>DTech AI Tutor</title>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
<style>
  :root { --primary: #4CAF50; --bg: #121212; --surface: #1e1e1e; --text: #e0e0e0; --msg-user: #4CAF50; --msg-ai: #2c2c2c; }
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: var(--bg); color: var(--text); margin: 0; display: flex; flex-direction: column; height: 100vh; height: 100dvh; overflow: hidden; }
  header { background-color: var(--surface); padding: 15px; text-align: center; border-bottom: 1px solid #333; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; }
  h1 { margin: 0; font-size: 1.2rem; color: var(--primary); font-weight: 700; }
  .icon-btn { background: none; border: none; color: #888; cursor: pointer; padding: 5px; border-radius: 50%; display: flex; align-items: center; justify-content: center; }
  .icon-btn:hover { color: white; background-color: rgba(255,255,255,0.1); }
  
  #chat-container { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 12px; scroll-behavior: smooth; }
  .message { max-width: 88%; padding: 12px 16px; border-radius: 18px; line-height: 1.5; word-wrap: break-word; font-size: 0.95rem; position: relative; }
  .user { align-self: flex-end; background-color: var(--msg-user); color: white; border-bottom-right-radius: 4px; }
  .ai { align-self: flex-start; background-color: var(--msg-ai); color: var(--text); border-bottom-left-radius: 4px; }
  
  /* Markdown Styles */
  .ai strong { color: #81c784; font-weight: 700; }
  .ai em { font-style: italic; color: #a5d6a7; }
  .ai ul, .ai ol { margin: 8px 0; padding-left: 20px; }
  .ai li { margin-bottom: 4px; }
  .ai pre { background: #1a1a1a; padding: 10px; border-radius: 8px; overflow-x: auto; margin: 8px 0; border: 1px solid #333; }
  .ai code { font-family: monospace; background: rgba(255,255,255,0.1); padding: 2px 4px; border-radius: 4px; font-size: 0.9em; }
  .ai pre code { background: none; padding: 0; color: #a5d6a7; }
  .tts-btn { position: absolute; bottom: -22px; left: 10px; font-size: 18px; color: #666; cursor: pointer; opacity: 0.7; transition: opacity 0.2s; padding: 2px; }
  .tts-btn:active { color: var(--primary); opacity: 1; }

  /* Suggestion Chips */
  #chips { display: flex; gap: 8px; padding: 10px 15px; overflow-x: auto; scrollbar-width: none; -ms-overflow-style: none; white-space: nowrap; flex-shrink: 0; }
  #chips::-webkit-scrollbar { display: none; }
  .chip { background: var(--surface); border: 1px solid #333; color: #aaa; padding: 6px 12px; border-radius: 16px; font-size: 0.85rem; cursor: pointer; transition: all 0.2s; }
  .chip:hover { border-color: var(--primary); color: var(--primary); }

  #input-area { background-color: var(--surface); padding: 10px; padding-bottom: max(10px, env(safe-area-inset-bottom)); display: flex; gap: 10px; border-top: 1px solid #333; flex-shrink: 0; align-items: center; }
  #input-wrapper { flex: 1; position: relative; display: flex; align-items: center; }
  input { width: 100%; padding: 12px 40px 12px 15px; border-radius: 24px; border: 1px solid #333; background-color: #2c2c2c; color: white; outline: none; font-size: 1rem; box-sizing: border-box; }
  input:focus { border-color: var(--primary); }
  
  #mic-btn { position: absolute; right: 8px; color: #888; background: none; border: none; cursor: pointer; }
  #mic-btn.listening { color: #f44336; animation: pulse 1.5s infinite; }
  
  #stop-speak-btn { color: #f44336; display: none; background: none; border: none; cursor: pointer; position: absolute; right: 40px; }
  
  #send-btn { background-color: var(--primary); color: white; border: none; width: 45px; height: 45px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background 0.2s; }
  #send-btn:hover { background-color: #43a047; }
  #send-btn:disabled { background-color: #2e5e30; opacity: 0.7; cursor: not-allowed; }
  
  @keyframes pulse { 0% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(1.1); } 100% { opacity: 1; transform: scale(1); } }
  
  /* Call Overlay */
  #call-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
  #call-overlay.active { opacity: 1; pointer-events: all; }
  .visualizer { width: 150px; height: 150px; border-radius: 50%; background: var(--primary); box-shadow: 0 0 30px var(--primary); animation: breathe 3s infinite ease-in-out; display: flex; align-items: center; justify-content: center; }
  .visualizer i { font-size: 64px; color: white; }
  @keyframes breathe { 0% { transform: scale(1); opacity: 0.8; } 50% { transform: scale(1.2); opacity: 0.4; } 100% { transform: scale(1); opacity: 0.8; } }
  .status-text { margin-top: 30px; font-size: 1.2rem; color: #888; letter-spacing: 1px; }
  
  .call-controls { display: flex; gap: 20px; margin-top: 60px; }
  #hangup-btn { background: #f44336; width: 60px; height: 60px; border-radius: 50%; border: none; color: white; font-size: 30px; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
  #stop-talk-call-btn { background: #555; width: 60px; height: 60px; border-radius: 50%; border: none; color: white; font-size: 30px; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.5); display: none; }

</style>
</head>
<body>
<div id="call-overlay">
  <div class="visualizer"><span class="material-icons-round" style="font-size: 64px; color: white;">graphic_eq</span></div>
  <div class="status-text" id="call-status">Listening...</div>
  <div class="call-controls">
      <button id="stop-talk-call-btn" title="Stop Speaking"><span class="material-icons-round">volume_off</span></button>
      <button id="hangup-btn" title="End Call"><span class="material-icons-round">call_end</span></button>
  </div>
</div>

<header>
  <h1>ðŸ‡¿ðŸ‡¦ DTech AI Assistant</h1>
  <div style="display:flex; gap:10px;">
    <button class="icon-btn" id="call-btn" title="Start Live Call"><span class="material-icons-round">headset_mic</span></button>
    <button class="icon-btn" id="clear-btn" title="Clear Chat"><span class="material-icons-round">delete_outline</span></button>
  </div>
</header>

<div id="chat-container"></div>

<div id="chips">
  <div class="chip">Explain simpler</div>
  <div class="chip">Give an example</div>
  <div class="chip">Quiz me</div>
  <div class="chip">Summarize</div>
</div>

<div id="image-preview" style="display:none; padding: 0 15px; margin-bottom: 5px;">
  <div style="position:relative; display:inline-block;">
    <img id="preview-img" style="height: 60px; border-radius: 8px; border: 1px solid #333;">
    <button id="remove-img" style="position:absolute; top:-5px; right:-5px; background:red; color:white; border-radius:50%; width:18px; height:18px; border:none; font-size:12px; cursor:pointer;">&times;</button>
  </div>
</div>

<form id="input-area">
  <div id="input-wrapper">
    <input type="file" id="file-input" accept="image/*" style="display:none">
    <button type="button" id="cam-btn" style="color:#888; background:none; border:none; cursor:pointer; padding-left:10px;"><span class="material-icons-round">add_a_photo</span></button>
    <input type="text" id="user-input" placeholder="Ask anything..." autocomplete="off" required>
    
    <button type="button" id="stop-speak-btn" title="Stop Speaking"><span class="material-icons-round">volume_off</span></button>
    <button type="button" id="mic-btn"><span class="material-icons-round">mic</span></button>
  </div>
  <button type="submit" id="send-btn"><span class="material-icons-round">send</span></button>
</form>

<script>
  // CONFIGURATION
  const WORKER_URL = "https://super-surf-282e.jonasmochebane.workers.dev/";

  const form = document.getElementById('input-area');
  const input = document.getElementById('user-input');
  const chat = document.getElementById('chat-container');
  const sendBtn = document.getElementById('send-btn');
  const micBtn = document.getElementById('mic-btn');
  const stopSpeakBtn = document.getElementById('stop-speak-btn');
  const clearBtn = document.getElementById('clear-btn');
  const camBtn = document.getElementById('cam-btn');
  const fileInput = document.getElementById('file-input');
  const previewContainer = document.getElementById('image-preview');
  const previewImg = document.getElementById('preview-img');
  const removeImgBtn = document.getElementById('remove-img');
  
  // Call UI
  const callBtn = document.getElementById('call-btn');
  const callOverlay = document.getElementById('call-overlay');
  const hangupBtn = document.getElementById('hangup-btn');
  const stopTalkCallBtn = document.getElementById('stop-talk-call-btn');
  const callStatus = document.getElementById('call-status');

  // State
  let history = JSON.parse(localStorage.getItem('dtech_history')) || [];
  let currentImageArray = null;
  let isCallActive = false;
  let isAIProcessing = false;
  let ttsBuffer = "";
  let shouldSpeakLive = false;
  let sseBuffer = ""; // Buffer for partial SSE lines
  
  // Init
  window.addEventListener('DOMContentLoaded', () => {
    if (history.length === 0) {
      addMessage("Hello! I'm your DTech AI assistant. How can I help you today?", 'ai', false);
    } else {
      history.forEach(msg => renderMessage(msg.content, msg.role));
      setTimeout(scrollToBottom, 100);
    }
  });

  // --- Core Logic ---

  function saveHistory() {
    localStorage.setItem('dtech_history', JSON.stringify(history));
  }

  function scrollToBottom() {
    chat.scrollTop = chat.scrollHeight;
  }

  // Markdown Parser
  function parseMarkdown(text) {
    let html = text
      .replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") // Escape
      .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>') // Code blocks
      .replace(/`([^`]+)`/g, '<code>$1</code>') // Inline code
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
      .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic
      .replace(/(?:^|\n)- (.*)/g, '<li>$1</li>') // List items
      .replace(/(<li>[\s\S]*?<\/li>)/g, '<ul>$1</ul>') // Wrap lists
      .replace(/\n/g, '<br>'); // Newlines
    
    // Fix lists (crude but effective for simple chats)
    html = html.replace(/<br><li>/g, '<li>');
    return html;
  }

  function renderMessage(text, role, isStreaming = false) {
    let div = document.getElementById(`msg-${history.length}`);
    
    // If it's a new message (not updating a stream)
    if (!div || !isStreaming) {
       div = document.createElement('div');
       div.classList.add('message', role);
       if (role === 'ai') {
           // Add TTS button
           const tts = document.createElement('span');
           tts.className = 'material-icons-round tts-btn';
           tts.innerText = 'volume_up';
           tts.onclick = () => speak(text);
           div.appendChild(tts);
       }
       chat.appendChild(div);
    }
    
    // Update content
    const contentHtml = parseMarkdown(text);
    // Use a content wrapper to preserve the TTS button
    const contentSpan = div.querySelector('.content') || document.createElement('div');
    contentSpan.className = 'content';
    contentSpan.innerHTML = contentHtml;
    if (!div.querySelector('.content')) div.prepend(contentSpan);
    
    scrollToBottom();
    return div;
  }

  function addMessage(text, role, save = true) {
    if (save) {
        history.push({ role, content: text });
        saveHistory();
    }
    renderMessage(text, role);
  }

  // --- Voice & Call Logic ---
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  let recognition;
  
  function speak(text, onEndCallback) {
    // If not appending to a queue (like manual click), clear everything
    if (!onEndCallback && !shouldSpeakLive) {
        window.speechSynthesis.cancel();
    }
    
    // Show Stop Button
    stopSpeakBtn.style.display = 'block';
    if(isCallActive) stopTalkCallBtn.style.display = 'block';

    // Strip markdown chars for smoother reading
    let cleanText = text.replace(/[*_#`]/g, '');
    const utterance = new SpeechSynthesisUtterance(cleanText);
    utterance.lang = 'en-ZA'; 
    utterance.rate = 1.1; 
    
    utterance.onend = () => {
        if (onEndCallback) onEndCallback();
        // Hide stop button if queue is empty
        if (!window.speechSynthesis.speaking) {
            stopSpeakBtn.style.display = 'none';
            stopTalkCallBtn.style.display = 'none';
        }
    };
    
    utterance.onerror = () => {
        stopSpeakBtn.style.display = 'none';
        stopTalkCallBtn.style.display = 'none';
    };

    window.speechSynthesis.speak(utterance);
  }

  function stopSpeaking() {
      window.speechSynthesis.cancel();
      stopSpeakBtn.style.display = 'none';
      stopTalkCallBtn.style.display = 'none';
      shouldSpeakLive = false; // Stop auto-reading for this stream
      ttsBuffer = "";
      
      // If in Call Mode, stopping speech should resume listening
      if (isCallActive) {
          isAIProcessing = false;
          callStatus.innerText = "Listening...";
          try { recognition.start(); } catch(e){}
      }
  }
  
  stopSpeakBtn.onclick = stopSpeaking;
  stopTalkCallBtn.onclick = stopSpeaking;

  // TTS Buffer Logic for Low Latency
  function processTTSBuffer(isFinal = false) {
      if (!shouldSpeakLive) return;

      // Split by sentence terminators
      // Match sentence endings followed by space or end of string
      const sentenceRegex = /([.?!]+[\s\n]+)/; 
      
      let parts = ttsBuffer.split(sentenceRegex);
      
      // If we have at least one complete sentence (part + delimiter + remainder)
      // split returns [text, delimiter, text, delimiter, remainder]
      
      while (parts.length > 2) {
          const sentence = parts.shift();
          const delimiter = parts.shift();
          const textToSpeak = sentence + delimiter;
          
          speak(textToSpeak, null); // Queue it up
      }
      
      // Reconstruct buffer with remainder
      ttsBuffer = parts.join('');
      
      // If final, speak the rest
      if (isFinal && ttsBuffer.trim()) {
          speak(ttsBuffer, () => {
              if (isCallActive) {
                  isAIProcessing = false;
                  callStatus.innerText = "Listening...";
                  try { recognition.start(); } catch(e){}
              }
          });
          ttsBuffer = "";
      }
  }


  if (SpeechRecognition) {
    recognition = new SpeechRecognition();
    recognition.continuous = false;
    recognition.interimResults = false;
    recognition.lang = 'en-ZA';

    // Standard Mic Button
    micBtn.onclick = () => {
        if (micBtn.classList.contains('listening')) recognition.stop();
        else recognition.start();
    };
    
    recognition.onstart = () => {
        micBtn.classList.add('listening');
        if (isCallActive) callStatus.innerText = "Listening...";
    };
    
    recognition.onend = () => {
        micBtn.classList.remove('listening');
        // Loop for Call Mode
        if (isCallActive && !isAIProcessing) {
             try { recognition.start(); } catch(e){}
        }
    };

    recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        
        if (isCallActive) {
            // Live Call Flow
            input.value = transcript; 
            isAIProcessing = true; 
            recognition.stop(); 
            callStatus.innerText = "Thinking...";
            form.requestSubmit(); 
        } else {
            // Standard Mic
            input.value = transcript;
            input.focus();
        }
    };
  } else {
    micBtn.style.display = 'none';
    callBtn.style.display = 'none';
  }

  // Call Mode Controls
  callBtn.onclick = () => {
    isCallActive = true;
    callOverlay.classList.add('active');
    try { recognition.start(); } catch(e){}
  };

  hangupBtn.onclick = () => {
    isCallActive = false;
    isAIProcessing = false;
    shouldSpeakLive = false;
    callOverlay.classList.remove('active');
    recognition.stop();
    window.speechSynthesis.cancel();
  };

  // --- Images ---

  camBtn.onclick = () => fileInput.click();
  
  fileInput.onchange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    // Show Preview
    const reader = new FileReader();
    reader.onload = (e) => {
        previewImg.src = e.target.result;
        previewContainer.style.display = 'block';
    };
    reader.readAsDataURL(file);

    // Process for Backend (Resize & Convert to Array)
    const img = new Image();
    img.src = URL.createObjectURL(file);
    await new Promise(r => img.onload = r);

    const canvas = document.createElement('canvas');
    const MAX_WIDTH = 800;
    const scaleSize = MAX_WIDTH / img.width;
    canvas.width = MAX_WIDTH;
    canvas.height = img.height * scaleSize;

    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    canvas.toBlob(async (blob) => {
        const buf = await blob.arrayBuffer();
        currentImageArray = Array.from(new Uint8Array(buf));
    }, 'image/jpeg', 0.7);
  };

  removeImgBtn.onclick = () => {
    fileInput.value = '';
    currentImageArray = null;
    previewContainer.style.display = 'none';
  };

  // --- Interaction ---
  
  clearBtn.onclick = () => {
    if(confirm('Clear conversation history?')) {
        history = [];
        saveHistory();
        chat.innerHTML = '';
        addMessage("Chat cleared. How can I help?", 'ai');
    }
  };

  document.querySelectorAll('.chip').forEach(chip => {
    chip.onclick = () => {
        input.value = chip.innerText;
        form.requestSubmit();
    };
  });

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const text = input.value.trim();
    if (!text && !currentImageArray) return;

    input.value = '';
    addMessage(text, 'user');
    
    // Create placeholder for AI
    const aiMsgIndex = history.length; 
    // Temp entry for streaming
    history.push({ role: 'ai', content: '' }); 
    const aiDiv = document.createElement('div');
    aiDiv.classList.add('message', 'ai');
    aiDiv.id = `msg-${aiMsgIndex}`;
    aiDiv.innerHTML = '<div class="content"><div class="loader" style="width:10px;height:10px;border-width:2px;animation:spin 1s linear infinite;"></div></div>';
    chat.appendChild(aiDiv);
    scrollToBottom();

    // Prepare Payload (Increased Context)
    const context = history.slice(0, -1).slice(-20); // Last 20 messages
    const payload = { messages: context };
    
    if (currentImageArray) {
        payload.image = currentImageArray;
        currentImageArray = null;
        fileInput.value = '';
        previewContainer.style.display = 'none';
    }

    // Init TTS Buffer if call or if user wants auto-speak (currently only call)
    ttsBuffer = "";
    shouldSpeakLive = isCallActive;
    if (shouldSpeakLive) {
        window.speechSynthesis.cancel();
        callStatus.innerText = "Speaking...";
    }

    try {
      const response = await fetch(WORKER_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) throw new Error(await response.text());

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let fullResponse = "";
      sseBuffer = "";

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        const chunk = decoder.decode(value, { stream: true });
        
        sseBuffer += chunk;
        const lines = sseBuffer.split('\n');
        // Keep the last partial line in the buffer
        sseBuffer = lines.pop(); 
        
        for (const line of lines) {
            if (line.startsWith('data: ')) {
                try {
                    const data = JSON.parse(line.slice(6));
                    if (data.response) {
                        fullResponse += data.response;
                        // Add to TTS buffer
                        ttsBuffer += data.response;
                        processTTSBuffer(false);
                        
                        // Update UI live
                        const contentDiv = aiDiv.querySelector('.content');
                        contentDiv.innerHTML = parseMarkdown(fullResponse);
                        scrollToBottom();
                    }
                } catch (e) { }
            }
        }
      }
      
      // Final Processing
      processTTSBuffer(true);

      // Final Save
      history[aiMsgIndex].content = fullResponse;
      saveHistory();
      
      // Add TTS button finally
      const tts = document.createElement('span');
      tts.className = 'material-icons-round tts-btn';
      tts.innerText = 'volume_up';
      tts.onclick = () => speak(fullResponse);
      aiDiv.appendChild(tts);

    } catch (err) {
      if (isCallActive) {
          speak("Sorry, I had a connection error.");
          isAIProcessing = false;
      }
      history.pop(); 
      
      let errorMsg = err.message;
      try {
          const jsonErr = JSON.parse(errorMsg);
          if (jsonErr.error) errorMsg = jsonErr.error;
      } catch (e) {}

      aiDiv.innerHTML = '<div class="content" style="color:#ff6b6b; border: 1px solid #ff6b6b; padding: 10px; border-radius: 8px; background: rgba(255, 107, 107, 0.1);"><strong>Error:</strong> ' + errorMsg + '</div>';
    }
  });
</script>
</body>
</html>
