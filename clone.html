<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>X24 DUPLICATOR</title>
  <meta name="d7b7595b9ebc7ba8de5c067e2685b8adf691089b" content="d7b7595b9ebc7ba8de5c067e2685b8adf691089b">
  <meta name="referrer" content="no-referrer-when-downgrade">
  
  <style>
    :root {
      --primary-bg: #0a0a14;
      --secondary-bg: #12121f;
      --card-bg: #161627;
      --accent-blue: #2563eb;
      --accent-blue-light: #3b82f6;
      --text-primary: #f3f4f6;
      --text-secondary: #d1d5db;
      --text-muted: #9ca3af;
      --border-color: #2d2d42;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--primary-bg);
      color: var(--text-primary);
      line-height: 1.6;
      padding: 20px;
    }
    
    .app-container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      background: var(--secondary-bg);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    h1 {
      font-size: 2.5rem;
      background: linear-gradient(90deg, var(--accent-blue), var(--accent-blue-light));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      margin-bottom: 10px;
    }
    
    .tagline {
      color: var(--text-secondary);
      font-size: 1.1rem;
    }
    
    .card {
      background-color: var(--secondary-bg);
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 24px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      border: 1px solid var(--border-color);
    }
    
    .input-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
    }
    
    @media (max-width: 900px) {
      .input-section {
        grid-template-columns: 1fr;
      }
    }
    
    .form-group {
      margin-bottom: 20px;
    }
    
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: var(--text-primary);
    }
    
    input[type="text"] {
      width: 100%;
      padding: 12px 16px;
      background-color: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-primary);
      font-size: 16px;
    }
    
    input[type="text"]:focus {
      outline: none;
      border-color: var(--accent-blue);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
    }
    
    .options-panel {
      background: var(--card-bg);
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
    }
    
    .options-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
    }
    
    .option-item {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .option-item input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }
    
    button {
      padding: 12px 20px;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .primary-btn {
      background: linear-gradient(to right, var(--accent-blue), var(--accent-blue-light));
      color: white;
    }
    
    .primary-btn:hover:not(:disabled) {
      background: linear-gradient(to right, #1d4ed8, #2563eb);
      transform: translateY(-2px);
    }
    
    .success-btn {
      background-color: var(--success);
      color: white;
    }
    
    .success-btn:hover:not(:disabled) {
      background-color: #059669;
      transform: translateY(-2px);
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }
    
    .progress-container {
      width: 100%;
      height: 8px;
      background: var(--card-bg);
      border-radius: 4px;
      margin: 20px 0;
      overflow: hidden;
    }
    
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-blue), var(--success));
      width: 0%;
      transition: width 0.3s ease;
    }
    
    .log-container {
      background: #111;
      color: #bfb;
      border-radius: 8px;
      padding: 16px;
      font-family: 'Consolas', 'Courier New', monospace;
      font-size: 14px;
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
    }
    
    .log-entry {
      margin-bottom: 8px;
      padding-left: 20px;
      position: relative;
      line-height: 1.4;
    }
    
    .log-entry:before {
      content: ">";
      position: absolute;
      left: 0;
      color: var(--success);
    }
    
    .log-entry.info {
      color: #a7c6fa;
    }
    
    .log-entry.success {
      color: var(--success);
    }
    
    .log-entry.warning {
      color: var(--warning);
    }
    
    .log-entry.error {
      color: var(--danger);
    }
    
    .output-container {
      position: relative;
    }
    
    textarea {
      width: 100%;
      height: 400px;
      padding: 16px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      font-family: 'Consolas', 'Courier New', monospace;
      font-size: 14px;
      resize: vertical;
      background: var(--card-bg);
      color: var(--text-primary);
    }
    
    .copy-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
    }
    
    .output-container:hover .copy-btn {
      opacity: 1;
    }
    
    .ad-notification {
      padding: 15px;
      margin: 20px 0;
      background: rgba(245, 158, 11, 0.1);
      border-left: 4px solid var(--warning);
      border-radius: 6px;
    }
    
    .timer-display {
      font-size: 18px;
      font-weight: bold;
      color: var(--warning);
      margin: 10px 0;
    }
    
    .instructions {
      color: var(--text-muted);
      font-size: 14px;
      margin-top: 10px;
    }
    
    .action-section {
      text-align: center;
      margin: 30px 0;
    }
    
    .button-group {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-top: 20px;
    }
    
    footer {
      text-align: center;
      margin-top: 30px;
      color: var(--text-muted);
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <header>
      <h1>X24 DUPLICATOR</h1>
      <p class="tagline">Download complete webpages with all resources properly handled</p>
    </header>
    
    <div class="card">
      <div class="input-group">
        <div class="form-group">
          <label for="urlInput">Enter webpage URL</label>
          <input type="text" id="urlInput" placeholder="https://example.com or /local.html">
        </div>
        
        <div class="form-group">
          <label>Action Required</label>
          <div class="ad-notification">
            <p><strong>Ad Requirement:</strong> You must watch an ad for 10 seconds to fetch pages</p>
            <div class="timer-display" id="timerDisplay">00:10</div>
            <p class="instructions" id="adInstructions">Click the button below to open the ad</p>
          </div>
        </div>
      </div>
      
      <div class="options-panel">
        <h3>Processing Options</h3>
        <div class="options-grid">
          <div class="option-item">
            <input type="checkbox" id="inlineCSS" checked>
            <label for="inlineCSS">Inline CSS</label>
          </div>
          <div class="option-item">
            <input type="checkbox" id="inlineImages" checked>
            <label for="inlineImages">Inline Images</label>
          </div>
          <div class="option-item">
            <input type="checkbox" id="inlineScripts">
            <label for="inlineScripts">Inline Scripts</label>
          </div>
          <div class="option-item">
            <input type="checkbox" id="fixPaths" checked>
            <label for="fixPaths">Fix Resource Paths</label>
          </div>
        </div>
      </div>
      
      <div class="action-section">
        <button class="primary-btn" id="adBtn">Watch Ad to Unlock Fetch</button>
        <button class="primary-btn" id="fetchBtn" disabled>Fetch Page</button>
        
        <div class="progress-container">
          <div class="progress-bar" id="progressBar"></div>
        </div>
        
        <div class="log-container" id="logContainer">
          <div class="log-entry info">Ready to fetch webpage...</div>
        </div>
      </div>
    </div>
    
    <div class="card">
      <div class="output-container">
        <textarea id="output" placeholder="Processed HTML will appear here..." spellcheck="false"></textarea>
        <button class="copy-btn" id="copyBtn">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
          Copy
        </button>
      </div>
      
      <div class="button-group">
        <button class="success-btn" id="downloadBtn" disabled>Download HTML</button>
      </div>
    </div>
    
    <footer>
      DTECH X24 HTML CLONE â€¢ Downloads complete webpages with all resources properly handled
    </footer>
  </div>

  <script>
    // State variables
    let processedHTML = '';
    let adWindow = null;
    let adStartTime = 0;
    let adTimeSpent = 0;
    let adTimerInterval = null;
    let fetchAdCompleted = false;
    let downloadAdCompleted = false;
    const AD_REQUIRED_TIME = 10; // seconds
    const proxy = "https://api.allorigins.win/raw?url=";
    
    // Elements
    const urlInput = document.getElementById('urlInput');
    const adBtn = document.getElementById('adBtn');
    const fetchBtn = document.getElementById('fetchBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const copyBtn = document.getElementById('copyBtn');
    const output = document.getElementById('output');
    const progressBar = document.getElementById('progressBar');
    const logContainer = document.getElementById('logContainer');
    const timerDisplay = document.getElementById('timerDisplay');
    const adInstructions = document.getElementById('adInstructions');
    
    // Initialize
    updateProgress(0);
    
    // Event listeners
    adBtn.addEventListener('click', startAdFlow);
    fetchBtn.addEventListener('click', fetchPage);
    downloadBtn.addEventListener('click', downloadHTML);
    copyBtn.addEventListener('click', copyToClipboard);
    
    // Ad flow for fetch functionality
    function startAdFlow() {
      if (!urlInput.value.trim()) {
        addLog('Please enter a URL first', 'error');
        return;
      }
      
      try {
        adWindow = window.open('https://otieu.com/4/9630811', '_blank');
        if (!adWindow || adWindow.closed || typeof adWindow.closed == 'undefined') {
          alert('Please allow popups for this site to view ads');
          return;
        }
      } catch (e) {
        alert('Please allow popups for this site to view ads');
        return;
      }
      
      adStartTime = Date.now();
      adTimeSpent = 0;
      adBtn.disabled = true;
      adBtn.textContent = 'Watching Ad...';
      adInstructions.textContent = 'Please keep the ad tab open for 10 seconds';
      fetchAdCompleted = false;
      
      // Start timer
      let remainingTime = AD_REQUIRED_TIME;
      timerDisplay.textContent = `00:${remainingTime.toString().padStart(2, '0')}`;
      
      adTimerInterval = setInterval(() => {
        remainingTime--;
        timerDisplay.textContent = `00:${remainingTime.toString().padStart(2, '0')}`;
        
        if (remainingTime <= 0) {
          clearInterval(adTimerInterval);
          adComplete('fetch');
        }
      }, 1000);
      
      // Check if user closed the ad window
      const checkAdWindow = setInterval(() => {
        try {
          if (adWindow.closed) {
            clearInterval(checkAdWindow);
            if (adTimeSpent < AD_REQUIRED_TIME) {
              adFailed('You closed the ad too early. Please watch for 10 seconds.');
            }
          }
        } catch (e) {
          // Cross-origin issue, we can't check if the window is closed
        }
      }, 1000);
    }
    
    function adComplete(type) {
      if (type === 'fetch') {
        fetchAdCompleted = true;
        fetchBtn.disabled = false;
        adBtn.style.display = 'none';
        timerDisplay.textContent = '00:00';
        timerDisplay.style.color = 'var(--success)';
        adInstructions.textContent = 'Ad requirement complete! You can now fetch the page';
        adInstructions.style.color = 'var(--success)';
      } else if (type === 'download') {
        downloadAdCompleted = true;
        // Proceed with download
        proceedWithDownload();
      }
      
      try {
        if (adWindow && !adWindow.closed) {
          adWindow.close();
        }
      } catch (e) {
        // Cross-origin issue
      }
    }
    
    function adFailed(message) {
      clearInterval(adTimerInterval);
      adBtn.disabled = false;
      adBtn.textContent = 'Watch Ad to Unlock Fetch';
      timerDisplay.textContent = '00:10';
      adInstructions.textContent = message;
      adInstructions.style.color = 'var(--error)';
      
      setTimeout(() => {
        adInstructions.textContent = 'Click the button below to open the ad';
        adInstructions.style.color = '';
      }, 3000);
    }
    
    // Add log entry
    function addLog(message, type = 'info') {
      const logEntry = document.createElement('div');
      logEntry.className = `log-entry ${type}`;
      logEntry.textContent = message;
      logContainer.appendChild(logEntry);
      logContainer.scrollTop = logContainer.scrollHeight;
    }
    
    // Update progress bar
    function updateProgress(percent) {
      progressBar.style.width = `${percent}%`;
    }
    
    // Show loading state
    function setLoading(isLoading) {
      fetchBtn.disabled = isLoading;
      if (isLoading) {
        fetchBtn.innerHTML = 'Fetching...';
      } else {
        fetchBtn.innerHTML = 'Fetch Page';
      }
    }
    
    // Fetch content with error handling
    async function fetchContent(url, options = {}) {
      try {
        addLog(`Fetching: ${url}`, 'info');
        const response = await fetch(url, options);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.text();
      } catch (e) {
        if (!url.startsWith('http')) {
          throw new Error('Local file access blocked by CORS. Try running this tool locally.');
        }
        addLog(`Using proxy for: ${url}`, 'warning');
        const proxyUrl = proxy + encodeURIComponent(url);
        const response = await fetch(proxyUrl);
        return await response.text();
      }
    }
    
    // Fetch binary content (for images, fonts, etc.)
    async function fetchBinary(url, options = {}) {
      try {
        addLog(`Fetching binary: ${url}`, 'info');
        const response = await fetch(url, options);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.blob();
      } catch (e) {
        if (!url.startsWith('http')) {
          throw new Error('Local file access blocked by CORS.');
        }
        addLog(`Using proxy for binary: ${url}`, 'warning');
        const proxyUrl = proxy + encodeURIComponent(url);
        const response = await fetch(proxyUrl);
        return await response.blob();
      }
    }
    
    // Process CSS resources with @import handling
    async function processCSS(doc, basePath) {
      const stylesheets = Array.from(doc.querySelectorAll('link[rel="stylesheet"]'));
      if (stylesheets.length === 0) {
        addLog('No external CSS found', 'info');
        return;
      }
      
      addLog(`Processing ${stylesheets.length} CSS files...`, 'info');
      updateProgress(10);
      
      for (const [index, link] of stylesheets.entries()) {
        const href = link.getAttribute('href');
        if (!href) continue;
        
        try {
          const cssUrl = href.startsWith('http') ? href : new URL(href, basePath).href;
          addLog(`[${index+1}/${stylesheets.length}] Loading CSS: ${cssUrl}`, 'info');
          
          let cssContent = await fetchContent(cssUrl);
          
          // Process @import rules recursively
          cssContent = await processImports(cssContent, cssUrl);
          
          // Create style tag with the CSS content
          const style = document.createElement('style');
          style.textContent = `/* Inlined from ${cssUrl} */\n${cssContent}`;
          link.replaceWith(style);
          
          addLog(`[${index+1}/${stylesheets.length}] CSS inlined successfully`, 'success');
          updateProgress(10 + ((index + 1) / stylesheets.length * 40));
        } catch (e) {
          addLog(`Failed to load CSS: ${href} - ${e.message}`, 'error');
          if (document.getElementById('fixPaths').checked && !href.startsWith('http')) {
            link.href = new URL(href, basePath).href;
            addLog(`Kept original CSS link with fixed path: ${link.href}`, 'warning');
          }
        }
      }
    }
    
    // Recursively process @import rules in CSS
    async function processImports(cssContent, baseUrl) {
      const importRegex = /@import\s+(url\()?['"]([^'"]+)['"]\)?[^;]*;/g;
      let match;
      let processedCSS = cssContent;
      
      while ((match = importRegex.exec(cssContent)) !== null) {
        const importPath = match[2];
        try {
          const importUrl = importPath.startsWith('http') ? importPath : new URL(importPath, baseUrl).href;
          addLog(`Processing CSS import: ${importUrl}`, 'info');
          
          const importedCSS = await fetchContent(importUrl);
          const processedImport = await processImports(importedCSS, importUrl);
          
          processedCSS = processedCSS.replace(match[0], processedImport);
        } catch (e) {
          addLog(`Failed to process CSS import: ${importPath} - ${e.message}`, 'error');
          if (document.getElementById('fixPaths').checked && !importPath.startsWith('http')) {
            const fixedImport = match[0].replace(importPath, new URL(importPath, baseUrl).href);
            processedCSS = processedCSS.replace(match[0], fixedImport);
            addLog(`Kept original @import with fixed path`, 'warning');
          }
        }
      }
      
      return processedCSS;
    }
    
    // Process image resources with srcset handling
    async function processImages(doc, basePath) {
      const images = Array.from(doc.querySelectorAll('img, [style*="background-image"]'));
      if (images.length === 0) {
        addLog('No images found', 'info');
        return;
      }
      
      addLog(`Processing ${images.length} images...`, 'info');
      updateProgress(50);
      
      for (const [index, element] of images.entries()) {
        try {
          if (element.tagName === 'IMG') {
            await processImgElement(element, basePath);
          } else if (element.style.backgroundImage) {
            await processBackgroundImage(element, basePath);
          }
          
          addLog(`[${index+1}/${images.length}] Image processed successfully`, 'success');
          updateProgress(50 + ((index + 1) / images.length * 40));
        } catch (e) {
          addLog(`Failed to process image: ${e.message}`, 'error');
        }
      }
    }
    
    // Process a single img element
    async function processImgElement(img, basePath) {
      const src = img.getAttribute('src');
      const srcset = img.getAttribute('srcset');
      
      if (src && !src.startsWith('data:')) {
        try {
          const imgUrl = src.startsWith('http') ? src : new URL(src, basePath).href;
          const blob = await fetchBinary(imgUrl);
          img.src = await blobToDataURL(blob);
        } catch (e) {
          addLog(`Failed to inline image src: ${src} - ${e.message}`, 'error');
          if (document.getElementById('fixPaths').checked && !src.startsWith('http')) {
            img.src = new URL(src, basePath).href;
            addLog(`Kept original src with fixed path: ${img.src}`, 'warning');
          }
        }
      }
      
      if (srcset) {
        try {
          const newSrcset = await processSrcset(srcset, basePath);
          img.setAttribute('srcset', newSrcset);
        } catch (e) {
          addLog(`Failed to process srcset: ${srcset} - ${e.message}`, 'error');
          if (document.getElementById('fixPaths').checked) {
            const fixedSrcset = fixSrcsetPaths(srcset, basePath);
            img.setAttribute('srcset', fixedSrcset);
            addLog(`Kept original srcset with fixed paths`, 'warning');
          }
        }
      }
    }
    
    // Process background images
    async function processBackgroundImage(element, basePath) {
      const bgImage = element.style.backgroundImage;
      const urlMatch = bgImage.match(/url\(['"]?(.*?)['"]?\)/);
      
      if (urlMatch && urlMatch[1]) {
        const imageUrl = urlMatch[1];
        if (!imageUrl.startsWith('data:')) {
          try {
            const fullUrl = imageUrl.startsWith('http') ? imageUrl : new URL(imageUrl, basePath).href;
            const blob = await fetchBinary(fullUrl);
            const dataUrl = await blobToDataURL(blob);
            element.style.backgroundImage = `url("${dataUrl}")`;
          } catch (e) {
            addLog(`Failed to inline background image: ${imageUrl} - ${e.message}`, 'error');
            if (document.getElementById('fixPaths').checked && !imageUrl.startsWith('http')) {
              element.style.backgroundImage = `url("${new URL(imageUrl, basePath).href}")`;
              addLog(`Kept original background image with fixed path`, 'warning');
            }
          }
        }
      }
    }
    
    // Process srcset attribute
    async function processSrcset(srcset, basePath) {
      const parts = srcset.split(',');
      const processedParts = [];
      
      for (const part of parts) {
        const [url, descriptor] = part.trim().split(/\s+/);
        if (!url) continue;
        
        try {
          const fullUrl = url.startsWith('http') ? url : new URL(url, basePath).href;
          const blob = await fetchBinary(fullUrl);
          const dataUrl = await blobToDataURL(blob);
          processedParts.push(`${dataUrl}${descriptor ? ' ' + descriptor : ''}`);
        } catch (e) {
          addLog(`Failed to inline srcset image: ${url} - ${e.message}`, 'error');
          if (document.getElementById('fixPaths').checked && !url.startsWith('http')) {
            processedParts.push(`${new URL(url, basePath).href}${descriptor ? ' ' + descriptor : ''}`);
            addLog(`Kept original srcset URL with fixed path`, 'warning');
          } else {
            processedParts.push(part.trim());
          }
        }
      }
      
      return processedParts.join(', ');
    }
    
    // Fix paths in srcset without inlining
    function fixSrcsetPaths(srcset, basePath) {
      return srcset.split(',').map(part => {
        const [url, descriptor] = part.trim().split(/\s+/);
        if (!url || url.startsWith('http') || url.startsWith('data:')) {
          return part.trim();
        }
        return `${new URL(url, basePath).href}${descriptor ? ' ' + descriptor : ''}`;
      }).join(', ');
    }
    
    // Convert blob to data URL
    function blobToDataURL(blob) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.readAsDataURL(blob);
      });
    }
    
    // Process script resources
    async function processScripts(doc, basePath) {
      if (!document.getElementById('inlineScripts').checked) {
        if (document.getElementById('fixPaths').checked) {
          const scripts = Array.from(doc.querySelectorAll('script[src]'));
          for (const script of scripts) {
            const src = script.getAttribute('src');
            if (src && !src.startsWith('http')) {
              script.src = new URL(src, basePath).href;
            }
          }
        }
        return;
      }
      
      const scripts = Array.from(doc.querySelectorAll('script[src]'));
      if (scripts.length === 0) {
        addLog('No external scripts found', 'info');
        return;
      }
      
      addLog(`Processing ${scripts.length} scripts...`, 'info');
      
      for (const [index, script] of scripts.entries()) {
        const src = script.getAttribute('src');
        if (!src) continue;
        
        try {
          const scriptUrl = src.startsWith('http') ? src : new URL(src, basePath).href;
          addLog(`[${index+1}/${scripts.length}] Loading script: ${scriptUrl}`, 'info');
          
          const scriptContent = await fetchContent(scriptUrl);
          
          const newScript = document.createElement('script');
          newScript.textContent = `/* Inlined from ${scriptUrl} */\n${scriptContent}`;
          script.replaceWith(newScript);
          
          addLog(`[${index+1}/${scripts.length}] Script inlined successfully`, 'success');
        } catch (e) {
          addLog(`Failed to load script: ${src} - ${e.message}`, 'error');
          if (document.getElementById('fixPaths').checked && !src.startsWith('http')) {
            script.src = new URL(src, basePath).href;
            addLog(`Kept original script with fixed path: ${script.src}`, 'warning');
          }
        }
      }
    }
    
    // Process other resources (links, fonts, etc.)
    async function processOtherResources(doc, basePath) {
      const favicon = doc.querySelector('link[rel*="icon"]');
      if (favicon) {
        const href = favicon.getAttribute('href');
        if (href && !href.startsWith('data:')) {
          try {
            const iconUrl = href.startsWith('http') ? href : new URL(href, basePath).href;
            const blob = await fetchBinary(iconUrl);
            favicon.href = await blobToDataURL(blob);
            addLog('Favicon inlined successfully', 'success');
          } catch (e) {
            addLog(`Failed to inline favicon: ${href} - ${e.message}`, 'error');
            if (document.getElementById('fixPaths').checked && !href.startsWith('http')) {
              favicon.href = new URL(href, basePath).href;
              addLog(`Kept original favicon with fixed path: ${favicon.href}`, 'warning');
            }
          }
        }
      }
      
      const styleTags = doc.querySelectorAll('style');
      for (const styleTag of styleTags) {
        const cssContent = styleTag.textContent;
        const updatedContent = await processFontsInCSS(cssContent, basePath);
        if (updatedContent !== cssContent) {
          styleTag.textContent = updatedContent;
        }
      }
    }
    
    // Process @font-face rules in CSS
    async function processFontsInCSS(cssContent, basePath) {
      const fontFaceRegex = /(@font-face\s*\{[^}]+\})/g;
      const srcRegex = /src:\s*(url\()?['"]([^'"]+)['"]\)?([^;]*);/g;
      let processedCSS = cssContent;
      let match;
      
      while ((match = fontFaceRegex.exec(cssContent)) !== null) {
        const fontFaceRule = match[1];
        let processedRule = fontFaceRule;
        let srcMatch;
        
        while ((srcMatch = srcRegex.exec(fontFaceRule)) !== null) {
          const fontUrl = srcMatch[2];
          if (fontUrl.startsWith('data:')) continue;
          
          try {
            const fullFontUrl = fontUrl.startsWith('http') ? fontUrl : new URL(fontUrl, basePath).href;
            const blob = await fetchBinary(fullFontUrl);
            const dataUrl = await blobToDataURL(blob);
            processedRule = processedRule.replace(srcMatch[0], `src: url("${dataUrl}")${srcMatch[3]};`);
            addLog(`Inlined font: ${fontUrl}`, 'success');
          } catch (e) {
            addLog(`Failed to inline font: ${fontUrl} - ${e.message}`, 'error');
            if (document.getElementById('fixPaths').checked && !fontUrl.startsWith('http')) {
              processedRule = processedRule.replace(
                srcMatch[0], 
                `src: url("${new URL(fontUrl, basePath).href}")${srcMatch[3]};`
              );
              addLog(`Kept original font with fixed path`, 'warning');
            }
          }
        }
        
        processedCSS = processedCSS.replace(fontFaceRule, processedRule);
      }
      
      return processedCSS;
    }
    
    // Build final HTML document
    function buildFinalHTML(doc) {
      addLog('Building final HTML structure...', 'info');
      
      const html = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${doc.title || 'Downloaded Page'}</title>
  ${getHeadContent(doc)}
</head>
<body>
  ${getBodyContent(doc)}
</body>
</html>`;
      
      return html;
    }
    
    function getHeadContent(doc) {
      const head = doc.head;
      let content = '';
      
      for (const child of head.children) {
        if (child.tagName !== 'TITLE' && child.getAttribute('name') !== 'viewport') {
          content += child.outerHTML + '\n';
        }
      }
      
      return content;
    }
    
    function getBodyContent(doc) {
      return doc.body.innerHTML;
    }
    
    // Main function to fetch and process page
    async function fetchPage() {
      const url = urlInput.value.trim();
      if (!url) {
        addLog('Please enter a URL', 'error');
        return;
      }
      
      if (!fetchAdCompleted) {
        addLog('Please watch the ad first to unlock fetching', 'error');
        return;
      }
      
      try {
        setLoading(true);
        output.value = '';
        downloadBtn.disabled = true;
        logContainer.innerHTML = '';
        updateProgress(0);
        addLog(`Starting fetch for: ${url}`, 'info');
        
        const html = await fetchContent(url);
        addLog('HTML content received, processing...', 'success');
        
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        const basePath = getBasePath(url);
        addLog(`Using base path: ${basePath}`, 'info');
        
        if (document.getElementById('inlineCSS').checked) {
          await processCSS(doc, basePath);
        } else if (document.getElementById('fixPaths').checked) {
          fixCSSPaths(doc, basePath);
        }
        
        if (document.getElementById('inlineImages').checked) {
          await processImages(doc, basePath);
        } else if (document.getElementById('fixPaths').checked) {
          fixImagePaths(doc, basePath);
        }
        
        await processScripts(doc, basePath);
        await processOtherResources(doc, basePath);
        
        let finalHTML = buildFinalHTML(doc);
        processedHTML = finalHTML;
        output.value = finalHTML;
        downloadBtn.disabled = false;
        updateProgress(100);
        addLog('Page processed successfully! Ready to download.', 'success');
      } catch (err) {
        addLog(`Error: ${err.message}`, 'error');
        console.error(err);
      } finally {
        setLoading(false);
      }
    }
    
    // Fix CSS paths without inlining
    function fixCSSPaths(doc, basePath) {
      const links = doc.querySelectorAll('link[rel="stylesheet"]');
      for (const link of links) {
        const href = link.getAttribute('href');
        if (href && !href.startsWith('http')) {
          link.href = new URL(href, basePath).href;
        }
      }
      addLog('Fixed CSS paths', 'success');
    }
    
    // Fix image paths without inlining
    function fixImagePaths(doc, basePath) {
      const images = doc.querySelectorAll('img');
      for (const img of images) {
        const src = img.getAttribute('src');
        if (src && !src.startsWith('http') && !src.startsWith('data:')) {
          img.src = new URL(src, basePath).href;
        }
        
        const srcset = img.getAttribute('srcset');
        if (srcset) {
          img.setAttribute('srcset', fixSrcsetPaths(srcset, basePath));
        }
      }
      addLog('Fixed image paths', 'success');
    }
    
    // Helper function to get base path
    function getBasePath(url) {
      if (url.startsWith('http')) {
        const urlObj = new URL(url);
        return `${urlObj.protocol}//${urlObj.host}${urlObj.pathname.split('/').slice(0, -1).join('/')}/`;
      }
      const lastSlash = url.lastIndexOf('/');
      return lastSlash > 0 ? url.substring(0, lastSlash + 1) : './';
    }
    
    // Download HTML file
    function downloadHTML() {
      if (!processedHTML) {
        addLog('No HTML to download. Please fetch a page first.', 'error');
        return;
      }
      
      // Start ad flow for download
      startDownloadAdFlow();
    }
    
    function startDownloadAdFlow() {
      try {
        adWindow = window.open('https://otieu.com/4/9630811', '_blank');
        if (!adWindow || adWindow.closed || typeof adWindow.closed == 'undefined') {
          alert('Please allow popups for this site to view ads');
          return;
        }
      } catch (e) {
        alert('Please allow popups for this site to view ads');
        return;
      }
      
      adStartTime = Date.now();
      adTimeSpent = 0;
      downloadAdCompleted = false;
      
      // Start timer
      let remainingTime = AD_REQUIRED_TIME;
      const downloadTimerDisplay = document.createElement('div');
      downloadTimerDisplay.className = 'timer-display';
      downloadTimerDisplay.textContent = `00:${remainingTime.toString().padStart(2, '0')}`;
      
      const downloadInstructions = document.createElement('p');
      downloadInstructions.className = 'instructions';
      downloadInstructions.textContent = 'Please keep the ad tab open for 10 seconds to download';
      
      const downloadNotification = document.createElement('div');
      downloadNotification.className = 'ad-notification';
      downloadNotification.innerHTML = '<p><strong>Ad Requirement:</strong> You must watch an ad for 10 seconds to download</p>';
      downloadNotification.appendChild(downloadTimerDisplay);
      downloadNotification.appendChild(downloadInstructions);
      
      document.querySelector('.button-group').insertBefore(downloadNotification, downloadBtn);
      
      const downloadTimerInterval = setInterval(() => {
        remainingTime--;
        downloadTimerDisplay.textContent = `00:${remainingTime.toString().padStart(2, '0')}`;
        
        if (remainingTime <= 0) {
          clearInterval(downloadTimerInterval);
          downloadNotification.remove();
          adComplete('download');
        }
      }, 1000);
      
      // Check if user closed the ad window
      const checkAdWindow = setInterval(() => {
        try {
          if (adWindow.closed) {
            clearInterval(checkAdWindow);
            clearInterval(downloadTimerInterval);
            downloadNotification.remove();
            if (adTimeSpent < AD_REQUIRED_TIME) {
              addLog('You closed the ad too early. Please watch for 10 seconds to download.', 'error');
            }
          }
        } catch (e) {
          // Cross-origin issue
        }
      }, 1000);
    }
    
    function proceedWithDownload() {
      const blob = new Blob([processedHTML], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      
      const filename = getDownloadFilename();
      addLog(`Downloading: ${filename}`, 'info');
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      addLog('Download complete!', 'success');
    }
    
    // Generate download filename
    function getDownloadFilename() {
      const url = urlInput.value.trim();
      if (!url) return 'downloaded_page.html';
      
      if (url.startsWith('http')) {
        const domain = new URL(url).hostname.replace('www.', '');
        const path = new URL(url).pathname.split('/').pop();
        return path ? `${domain}_${path}` : `${domain}.html`;
      }
      
      const filename = url.split('/').pop();
      return filename.endsWith('.html') ? filename : `${filename}.html`;
    }
    
    // Copy to clipboard
    function copyToClipboard() {
      output.select();
      document.execCommand('copy');
      
      copyBtn.innerHTML = 'Copied!';
      
      setTimeout(() => {
        copyBtn.innerHTML = 'Copy';
      }, 2000);
      
      addLog('HTML copied to clipboard', 'success');
    }
  </script>
</body>
</html>