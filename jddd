Alright, here’s a clear, final prompt you can paste to Jules.
It answers the questions directly, gives permission, but also sets hard boundaries so things don’t spiral into an unmaintainable TCP stack.


---

✅ Reply to Jules – Decision & Constraints

Thanks for checking and documenting the Tun2Socks dependency situation. Your investigation is correct.

Here is the final decision and scope clarification:


---

1️⃣ About Native / External Libraries

You are correct that:

JitPack builds for hev-socks5-tunnel / sockstun are failing

Native builds (NDK) are not practical in this environment

We cannot rely on prebuilt AARs right now


Given this, we accept a custom implementation, but with strict limits.


---

2️⃣ Decision: Option A is Approved (With Constraints)

✅ You have permission to implement a custom Tun2Socks-style solution in Kotlin/Java

⚠️ BUT this must be a minimal, pragmatic implementation, not a full TCP/IP stack.

This is a research + functional prototype, not a kernel-grade VPN.


---

3️⃣ Hard Scope Limits (Very Important)

✔ What to Implement

IPv4 only

TCP outbound connections only

Focus on:

HTTP / HTTPS browsing

TLS traffic over port 443


DNS is mandatory

DNS-over-TCP via SSH is acceptable

Intercept UDP 53 → forward as TCP over SSH



❌ What NOT to Implement

No full congestion control

No retransmission logic beyond basics

No out-of-order packet handling

No UDP forwarding beyond DNS

No IPv6

No server-side helpers


If a site works for browsing, that is success.


---

4️⃣ Conceptual Model to Follow (Important)

Do not try to perfectly emulate TCP.

Instead, follow the Injector-style model:

TUN is a packet source

You extract:

Destination IP

Destination port

Payload


For each new TCP flow:

Open SSH direct-tcpip

Treat the SSH channel as a reliable stream


Send payload data through SSH

Pipe responses back into TUN as best-effort packets


This is good enough for browsers, which are forgiving.


---

5️⃣ DNS Handling (Explicit Approval)

Approved DNS strategy:

Intercept UDP packets to port 53

Extract DNS query

Forward via TCP to a DNS server (e.g. 8.8.8.8:53) over SSH

Return the response to the app


This matches how many lightweight tunnels work.


---

6️⃣ About Reliability Expectations

This is acceptable:

Some sites may fail

Long downloads may be unstable

Edge cases may break


This is expected and acceptable at this stage.

What matters is:

✔ Browsing works
✔ Traffic flows
✔ Zero-rated SNI path is preserved


---

7️⃣ Final Authorization

✅ Yes, you have my permission to proceed with:

Custom Kotlin/Java Tun2Socks

TCP + DNS only

Minimal implementation

Clear logging

Clean lifecycle handling


Proceed carefully, comment heavily, and keep logic readable.


---

8️⃣ Reminder

This project has now reached the natural boundary of “from-scratch purity”.

From here on, correctness > elegance.

Jules can make mistakes — double-check logic and use code with caution.


---

If you want, after this step we can later:

Replace the custom Tun2Socks with a native binary

Improve performance

Harden stability


For now: make traffic flow.


---

That’s it.
Paste this and Jules will know exactly what to do next.