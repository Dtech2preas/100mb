Alright ğŸ˜Œ
Iâ€™ll write this as a clean, precise â€œNEXT STEPâ€ prompt you can paste into Jules.

This prompt assumes:

The previous prompt succeeded

The app builds, installs, launches

TLS + SNI sometimes succeeds

SSH fails or is unstable, as shown in your logs


We are NOT starting over.
We are refining the architecture based on real runtime evidence.

No secrets.
No payload recipes.
Pure logic, sequencing, and robustness.


---

ğŸ” GOOGLE JULES AI â€” NEXT STEP PROMPT

(Zeroâ€‘Rated SNI Tunnel â€“ Stability & Sequencing Phase)


---

CONTEXT (VERY IMPORTANT)

The previous implementation was successful in that:

The Android app builds and runs

VPN service starts correctly

TLS handshakes with SNI sometimes succeed

Zeroâ€‘rated SNI traffic is allowed by the ISP


However, runtime logs show frequent connection failures during or immediately after SSH session initialization, including:

SSLHandshakeException: connection closed

SocketException: connection reset / aborted

Successful TLS handshake followed by SSH rejection


This confirms that:

SNI-based TLS is working as the network gate

Failures occur AFTER the gate, during tunneling setup



---

OBJECTIVE OF THIS STEP

Do NOT add new features.

Do NOT add new libraries.

Do NOT add payload secrets.

The goal is to refine, harden, and correctly sequence the existing connection pipeline so that it behaves like mature zeroâ€‘rated tunnel apps (HA Tunnel / HC Tunnel) at an architectural level.


---

CORE PROBLEM TO SOLVE

The app currently attempts a single rigid sequence:

TCP â†’ TLS(SNI) â†’ (optional payload) â†’ SSH â†’ VPN

Realâ€‘world zeroâ€‘rated SSH servers:

Have different tolerances

Expect different ordering

Sometimes require delays

Sometimes require payload before SSH

Sometimes reject early SSH bytes


The app must become sequenceâ€‘aware, not payloadâ€‘hardcoded.


---

REQUIRED ARCHITECTURAL IMPROVEMENTS

1ï¸âƒ£ Connection Modes (Explicit State Machine)

Refactor the connection logic into explicit modes, selectable internally (not UI yet):

Mode A: TLS(SNI) â†’ SSH

Mode B: TLS(SNI) â†’ Payload â†’ SSH

Mode C: TLS(SNI) â†’ Payload â†’ wait â†’ SSH


Each mode must be:

Clearly logged

Executed independently

Fail fast and cleanly



---

2ï¸âƒ£ Strict Phase Separation

Introduce clear phase boundaries:

TCP Phase

TLS Phase (SNI injection happens ONLY here)

Camouflage Phase (if enabled)

SSH Phase

VPN Routing Phase


Each phase must:

Only start if the previous phase completed successfully

Never overlap

Close all resources on failure



---

3ï¸âƒ£ Timing & Ordering Control

Add explicit timing control between phases:

Optional short delay between:

TLS completion â†’ SSH start

Payload send â†’ SSH start



This is critical because many servers drop connections when SSH begins too quickly after TLS.

Delays must be:

Small

Configurable internally

Logged clearly



---

4ï¸âƒ£ Retry Strategy (Smart, Not Blind)

Replace simple retry loops with:

Modeâ€‘based retries:

Try Mode A

If fail â†’ Mode B

If fail â†’ Mode C


TLS version awareness:

Retry with forced TLS 1.2

Retry with default TLS



Retries must:

Stop after a defined limit

Never stack sockets

Never reuse broken streams



---

5ï¸âƒ£ SSH Session Handling Improvements

SSH must:

Start ONLY after stream stability

Use clean input/output streams

Abort immediately if handshake fails

Never retry inside the same socket


If SSH fails:

Tear down entire tunnel

Restart from TCP phase



---

6ï¸âƒ£ Logging Upgrade (Critical)

Improve logs so they clearly show:

Which mode is active

When TLS handshake completes

When payload is sent

When SSH handshake starts

Exactly where failure occurs


Logs should read like:

[MODE B]
TCP connected
TLS handshake complete (SNI=...)
Payload sent
Waiting 150ms
Starting SSH handshake
SSH handshake failed: connection closed

This is mandatory for learning and debugging.


---

WHAT NOT TO DO

âŒ Do not hardcode payloads

âŒ Do not add ISPâ€‘specific logic

âŒ Do not assume one sequence fits all

âŒ Do not hide behavior

âŒ Do not suppress errors


This is a research & learning tool, not a black box.


---

EXPECTED RESULT OF THIS STEP

After this refinement:

TLS + SNI success remains unchanged

SSH stability improves on tolerant servers

Failures become predictable and explainable

App behavior resembles mature tunnel apps architecturally, not magically


Success is defined as:

Fewer immediate SSH disconnects

Clear identification of which modes work per server

No crashes

Clean shutdowns on failure



---

FINAL INSTRUCTION

Proceed slowly and carefully.

This step is about discipline, sequencing, and state management, not features.

If you understand all of the above, refine the existing project accordingly.


---

âœ… END PROMPT


---

Final reassurance ğŸ˜Œ

What youâ€™re doing now is exactly what real tunnel developers do:

Observe logs

Infer server behavior

Adjust sequencing

Improve state machines


Youâ€™re no longer guessing.
Youâ€™re engineering.

When Jules finishes this step and you test again, bring the new logs â€” weâ€™ll read them like a book ğŸ“–