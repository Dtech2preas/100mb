<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>D-TECH Subdomain Creator</title>
<style>
  #notification-container > div { padding:6px; margin:6px 0; background:#eef; border-radius:6px; }
  #log { height:220px; overflow:auto; background:#111; color:#bfb; padding:12px; border-radius:6px; white-space:pre-wrap; }
  input { width:100%; padding:8px; margin:6px 0; box-sizing:border-box; }
  button { margin:4px; padding:8px 12px; }
  #name-status { margin:6px 0; font-weight:600; }
</style>
</head>
<body>
<div id="notification-container"></div>

<h1>D-TECH Subdomain Creator</h1>
<p>Create custom subdomains for your gist URLs</p>

<div>
  <p>Important Notice: Your URL: <strong>https://[name].log-in.co.za</strong></p>
  <p>Subdomains with &lt;1 hour may be removed at any time</p>
  <p>Activation Notice: URL may take 1-2 minutes to become active. IF IT DOESN'T WORK THE FIRST TIME, THE SECOND TIME IT WILL 100% WORK</p>
</div>

<div>
  <label for="name">Subdomain Name</label>
  <input type="text" id="name" placeholder="Enter your subdomain name (e.g. lefa)" autocomplete="off" />
  <div id="name-status"></div>
  <p>Use lowercase letters and dashes (-) only</p>
  <p>Result: <span id="preview-url">https://.log-in.co.za</span></p>
</div>

<div>
  <label for="url">Gist URL (Required for creation)</label>
  <input type="url" id="url" placeholder="https://gist.github.com/..." />
</div>

<div>
  <button id="ad-btn">Press Ad to Get 2 Actions (Must Wait 15s)</button>
  <button id="create-btn" disabled>Create (2h)</button>
  <button id="extend-btn" disabled>Extend 12h</button>
  <button id="check-btn">Check Time</button>
  <span style="margin-left:14px">Credits: <span id="credits-display">0</span></span>
</div>

<div>
  URL activation may take 1-2 minutes
</div>

<div id="url-display" style="display:none; margin-top:8px;">
  <h3>Your Subdomain URL</h3>
  <div id="final-url">https://example.log-in.co.za</div>
  <button id="copy-btn">Copy</button>
</div>

<div style="margin-top:12px;">
  <h3>System Log</h3>
  <span id="status-indicator"></span>
  <pre id="log">System ready. Press the ad button to get credits.</pre>
</div>

<script>
/* ---------- CONFIG ---------- */
const MAPPING_RAW_URL = "https://gist.githubusercontent.com/Preasx24/451a35def0daf123212fcb9729d3dfdd/raw/gistfile1.txt";
const TOKEN_RAW_URL = "https://gist.githubusercontent.com/Preasx24/137f29d4b3b32c251bf6b7ab2b3fae28/raw/gistfile1.txt";
const GIST_ID = "451a35def0daf123212fcb9729d3dfdd";
const CACHE_TTL = 30000;                // 30s cache for mapping
const INITIAL_DURATION = 7200;          // 2 hours (seconds)
const EXTENSION_DURATION = 43200;       // 12 hours (seconds)
const AD_WAIT_MS = 15000;               // 15 seconds required

/* ---------- STATE ---------- */
let mappingCache = null;
let lastCacheTime = 0;
let adWindow = null;
let adStartTime = 0;
let adPending = false;
let lastAdAwardAt = 0;
let credits = 0;
let pollingInterval = null;
let opInProgress = false;               // single UI-level mutex

/* ---------- ELEMENTS ---------- */
const el = {
  notif: document.getElementById('notification-container'),
  log: document.getElementById('log'),
  nameInput: document.getElementById('name'),
  nameStatus: document.getElementById('name-status'),
  previewUrl: document.getElementById('preview-url'),
  urlInput: document.getElementById('url'),
  adBtn: document.getElementById('ad-btn'),
  createBtn: document.getElementById('create-btn'),
  extendBtn: document.getElementById('extend-btn'),
  checkBtn: document.getElementById('check-btn'),
  finalUrl: document.getElementById('final-url'),
  urlDisplay: document.getElementById('url-display'),
  copyBtn: document.getElementById('copy-btn'),
  creditsDisplay: document.getElementById('credits-display')
};

/* ---------- UTIL ---------- */
const getUnix = () => Math.floor(Date.now() / 1000);
const nowMs = () => Date.now();

const sanitizeName = (s) => (s||'').toLowerCase().replace(/[^a-z0-9-]/g,'').replace(/-+/g,'-').replace(/^-|-$/g,'');

const showNotification = (msg, timeout = 3500) => {
  const d = document.createElement('div'); d.textContent = msg; el.notif.appendChild(d);
  setTimeout(() => d.remove(), timeout);
};

const log = (msg) => {
  const t = new Date().toLocaleTimeString();
  const lines = el.log.textContent.split('\n').slice(0, 200);
  el.log.textContent = `[${t}] ${msg}\n${lines.join('\n')}`;
  el.log.scrollTop = el.log.scrollHeight;
};

const updateCreditsUI = () => {
  el.creditsDisplay.textContent = credits;
};

/* ---------- NETWORK ---------- */
async function fetchRawText(url) {
  const r = await fetch(`${url}?t=${Date.now()}`, { cache: "no-store" });
  if (!r.ok) throw new Error(`HTTP ${r.status}`);
  return await r.text();
}

async function getMapping() {
  try {
    const now = nowMs();
    if (mappingCache && now - lastCacheTime < CACHE_TTL) return mappingCache;
    const text = await fetchRawText(MAPPING_RAW_URL);
    let parsed = {};
    if (!text || !text.trim()) parsed = {};
    else {
      try { parsed = JSON.parse(text); } 
      catch(e) {
        const maybeStart = text.indexOf('{'), maybeEnd = text.lastIndexOf('}');
        if (maybeStart >= 0 && maybeEnd > maybeStart) {
          try { parsed = JSON.parse(text.substring(maybeStart, maybeEnd+1)); }
          catch(_) { parsed = {}; log('Warning: mapping parse failed, using empty mapping'); }
        } else parsed = {};
      }
    }
    if (!parsed || typeof parsed !== 'object') parsed = {};
    if (!parsed._expires) parsed._expires = {};
    // normalize expiry values to numbers (avoid strings)
    for (const k of Object.keys(parsed._expires || {})) {
      const v = parsed._expires[k];
      parsed._expires[k] = Number(v) || 0;
    }
    mappingCache = parsed;
    lastCacheTime = now;
    return parsed;
  } catch (e) {
    log(`Failed to fetch mapping: ${e.message}`);
    return { _expires: {} };
  }
}

/**
 * updateMapping safely merges with latest gist content and patches.
 * It no longer throws for opInProgress — opInProgress is handled at the caller level.
 */
async function updateMapping(newMapping) {
  // Fetch latest raw text and merge conservatively
  const latestText = await fetchRawText(MAPPING_RAW_URL);
  let latest = {};
  if (latestText && latestText.trim()) {
    try { latest = JSON.parse(latestText); } catch(e) { latest = {}; }
  }
  const merged = Object.assign({}, latest, newMapping || {});
  if (!merged._expires) merged._expires = {};
  // for any names present in both latest and merged, ensure we prefer the larger expiry
  for (const k of Object.keys(latest._expires || {})) {
    const latestVal = Number((latest._expires||{})[k]) || 0;
    const mergedVal = Number((merged._expires||{})[k]) || 0;
    merged._expires[k] = Math.max(latestVal, mergedVal);
  }

  // fetch token
  const tokenRes = await fetch(`${TOKEN_RAW_URL}?t=${Date.now()}`, { cache: "no-store" });
  if (!tokenRes.ok) throw new Error(`Token fetch failed ${tokenRes.status}`);
  const tokenText = await tokenRes.text();
  const token = tokenText.split('\n')[0].trim();
  if (!token) throw new Error('No token available');

  const res = await fetch(`https://api.github.com/gists/${GIST_ID}`, {
    method: 'PATCH',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Accept': 'application/vnd.github.v3+json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ files: { "gistfile1.txt": { content: JSON.stringify(merged, null, 2) } } })
  });
  if (!res.ok) {
    const t = await res.text();
    throw new Error(`Gist patch failed ${res.status}: ${t.slice(0,200)}`);
  }
  // update local cache
  mappingCache = merged;
  lastCacheTime = nowMs();
  log('Mapping updated on gist.');
  return merged;
}

/* ---------- AD / CREDITS logic ---------- */
function startAdFlow() {
  if (adPending) return showNotification('Ad already open — return after 15s');
  try { adWindow = window.open('https://otieu.com/4/9630811', '_blank'); } catch (e) { adWindow = null; }
  adStartTime = nowMs();
  adPending = true;
  lastAdAwardAt = 0;
  showNotification('Ad opened. Return after at least 15 seconds.');
  log(`Ad started at ${new Date(adStartTime).toLocaleTimeString()}`);
  if (pollingInterval) clearInterval(pollingInterval);
  pollingInterval = setInterval(() => {
    if (!adPending) { clearInterval(pollingInterval); pollingInterval = null; return; }
    if (adWindow && adWindow.closed) handleReturnFromAd();
  }, 800);
}

function awardAdCreditsIfEligible() {
  if (!adPending) return;
  const elapsed = nowMs() - adStartTime;
  if (elapsed < AD_WAIT_MS) {
    showNotification(`You returned too early (${Math.floor(elapsed/1000)}s). Wait at least 15s.`);
    log(`Ad returned too early: ${Math.floor(elapsed/1000)}s`);
    return;
  }
  // prevent duplicate awards in same session
  if (lastAdAwardAt && Math.abs(lastAdAwardAt - adStartTime) < 1000) return;
  lastAdAwardAt = adStartTime;
  credits += 2;
  updateCreditsUI();
  showNotification(`Ad complete — awarded 2 credits. Credits: ${credits}`);
  log(`Ad awarded 2 credits at ${new Date().toLocaleTimeString()}. Total credits: ${credits}`);
  adPending = false;
  try { if (adWindow && !adWindow.closed) adWindow.close(); } catch(e){}
  adWindow = null;
  if (pollingInterval) { clearInterval(pollingInterval); pollingInterval = null; }
  refreshButtonsBasedOnName();
}

function handleReturnFromAd() {
  try { awardAdCreditsIfEligible(); } catch (e) { log('Error awarding ad credits: ' + e.message); }
}

window.addEventListener('focus', () => { if (adPending) handleReturnFromAd(); });
document.addEventListener('visibilitychange', () => { if (adPending && !document.hidden) handleReturnFromAd(); });
el.adBtn.addEventListener('click', () => startAdFlow());

/* ---------- UI state based on name ---------- */
async function refreshButtonsBasedOnName() {
  const name = sanitizeName(el.nameInput.value.trim());
  if (!name) {
    el.nameStatus.textContent = '';
    el.createBtn.disabled = true;
    el.extendBtn.disabled = true;
    return;
  }
  try {
    const mapping = await getMapping();
    const exists = Boolean(mapping[name]);
    if (exists) {
      el.nameStatus.textContent = `"${name}" already exists — you can extend (if you have credits).`;
      el.createBtn.disabled = true;
      el.extendBtn.disabled = opInProgress || credits <= 0;
    } else {
      el.nameStatus.textContent = `"${name}" is available — you can create it (if you have credits).`;
      el.createBtn.disabled = opInProgress || credits <= 0;
      el.extendBtn.disabled = true;
    }
  } catch (e) {
    el.nameStatus.textContent = 'Name check failed';
    el.createBtn.disabled = true;
    el.extendBtn.disabled = true;
  }
  updateCreditsUI();
}

/* ---------- CORE: create / extend / check ---------- */
async function handleAction(mode) {
  // Guard: single UI-level mutex prevents overlapping create/extend
  if (opInProgress) return showNotification('Operation in progress — please wait...');
  const name = sanitizeName(el.nameInput.value.trim());
  const url = el.urlInput.value.trim();
  if (!name) return showNotification('Enter subdomain name.');
  if (mode === 'create' && !url) return showNotification('Enter URL to point the subdomain to.');
  if (credits <= 0) return showNotification('No credits — press the ad button and wait 15s.');

  // Begin operation: set mutex, disable buttons to block further clicks.
  opInProgress = true;
  el.createBtn.disabled = true;
  el.extendBtn.disabled = true;

  try {
    log(`Starting ${mode} for ${name} ...`);
    const mapping = await getMapping();
    if (!mapping._expires) mapping._expires = {};
    // read & normalize current expiry
    const rawExpiry = mapping._expires[name];
    const currentExpiry = (typeof rawExpiry === 'number' && rawExpiry > 0) ? rawExpiry : getUnix();

    if (mode === 'create') {
      if (mapping[name]) {
        showNotification('Subdomain already exists — cannot create. Use extend.');
        log('Create aborted: already exists.');
        return;
      }
      mapping[name] = url;
      mapping._expires[name] = Math.max(currentExpiry, getUnix()) + INITIAL_DURATION;
      el.finalUrl.textContent = `https://${name}.log-in.co.za`;
      el.urlDisplay.style.display = 'block';
    } else { // extend
      if (!mapping[name]) {
        showNotification('Subdomain does not exist — create it first.');
        log('Extend aborted: does not exist.');
        return;
      }
      mapping._expires[name] = Math.max(currentExpiry, getUnix()) + EXTENSION_DURATION;
    }

    // attempt merge-and-patch
    const updated = await updateMapping(mapping);

    // consume credit only after successful update
    credits = Math.max(0, credits - 1);
    updateCreditsUI();
    showNotification(`${mode} successful. Credits left: ${credits}`);
    log(`${mode} done for ${name}. Credits left: ${credits}. New expiry: ${Number(updated._expires[name]||0)}`);

    // refresh UI (availability & button enablement)
    await refreshButtonsBasedOnName();
  } catch (e) {
    log(`Error during ${mode}: ${e.message}`);
    showNotification(`Operation failed: ${e.message}`);
  } finally {
    opInProgress = false;
    // re-evaluate UI state
    await refreshButtonsBasedOnName();
  }
}

el.createBtn.addEventListener('click', () => handleAction('create'));
el.extendBtn.addEventListener('click', () => handleAction('extend'));

/* ---------- check time ---------- */
async function checkTime() {
  const name = sanitizeName(el.nameInput.value.trim());
  if (!name) return showNotification('Enter a name first');
  try {
    const mapping = await getMapping();
    const expires = mapping._expires?.[name];
    if (!expires) { log('No expiry set'); showNotification('No expiry set'); return; }
    const remaining = Math.max(0, Number(expires) - getUnix());
    const mins = Math.floor(remaining / 60);
    const hrs = Math.floor(mins / 60);
    const minPart = mins % 60;
    log(`Time remaining for ${name}: ${hrs}h ${minPart}m`);
  } catch (e) {
    log('Check time failed: ' + e.message);
    showNotification('Check failed');
  }
}
el.checkBtn.addEventListener('click', checkTime);

/* ---------- input handlers ---------- */
el.nameInput.addEventListener('input', () => {
  const name = sanitizeName(el.nameInput.value);
  el.nameInput.value = name;
  el.previewUrl.textContent = `https://${name || '[name]'}.log-in.co.za`;
  if (el.nameInput._timer) clearTimeout(el.nameInput._timer);
  el.nameInput._timer = setTimeout(() => refreshButtonsBasedOnName(), 300);
});

el.copyBtn.addEventListener('click', async () => {
  try { await navigator.clipboard.writeText(el.finalUrl.textContent); showNotification('URL copied!'); }
  catch { showNotification('Failed to copy'); }
});

/* ---------- init ---------- */
(async function init() {
  try {
    await refreshButtonsBasedOnName();
    log('System ready. Press the ad button to get credits.');
  } catch (e) {
    log('Init error: ' + e.message);
  }
})();
</script>
</body>
</html>